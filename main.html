<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CU Boulder AED Inventory Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
    <!-- PDF Generation Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        
        .main-container {
            display: flex;
            width: 100%;
            height: 100vh;
            position: relative;
        }
        
        #map {
            flex-grow: 1;
            height: 100%;
            border-left: 1px solid #dee2e6;
            cursor: grab;
            transition: margin-left 0.3s ease;
        }
        
        .leaflet-marker-icon.leaflet-draggable {
            cursor: move;
        }
        
        #summary {
            width: 450px;
            min-width: 250px;
            max-width: 60%;
            height: 100%;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
            background-color: #f8f9fa;
            border-right: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
            position: relative;
            transition: width 0.3s ease;
        }
        
        /* Resizer handle */
        .resize-handle {
            width: 6px;
            background: #dee2e6;
            cursor: ew-resize;
            position: absolute;
            top: 0;
            right: -3px;
            bottom: 0;
            z-index: 1000;
            transition: background-color 0.2s;
            opacity: 0.7;
        }
        
        .resize-handle:hover {
            background: #007bff;
            opacity: 1;
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
        }
        
        .resize-handle.dragging {
            background: #007bff;
            opacity: 1;
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.5);
        }
        
        .resize-handle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 30px;
            background: currentColor;
            border-radius: 1px;
            opacity: 0.5;
        }
        
        /* Focus mode styles */
        .focus-mode-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1001;
        }
        
        .focus-toggle {
            padding: 8px 12px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background-color 0.2s;
        }
        
        .focus-toggle:hover {
            background: #5a6268;
        }
        
        .focus-toggle.active {
            background: #28a745;
        }
        
        .focus-toggle.active:hover {
            background: #218838;
        }
        
        /* Hidden buttons in focus mode */
        .button-controls {
            transition: opacity 0.3s ease, max-height 0.3s ease;
            overflow: hidden;
        }
        
        .focus-mode .button-controls {
            opacity: 0;
            max-height: 0;
            margin: 0;
            padding: 0;
            pointer-events: none;
        }
        
        .focus-mode .instructions {
            display: none !important;
        }
        
        .focus-mode .summary-header h1 {
            font-size: 1.2em;
            margin-bottom: 10px;
        }
        
        /* Enhance work block visibility in focus mode */
        .focus-mode .cluster {
            margin-bottom: 15px;
            border-width: 2px;
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
        }
        
        .focus-mode .cluster-header {
            font-size: 1.1em;
            padding: 10px 12px;
        }
        
        .focus-mode .cluster li {
            padding: 10px 12px;
        }
        
        /* Keyboard shortcut hint */
        .focus-toggle::after {
            content: ' (F)';
            font-size: 0.7em;
            opacity: 0.7;
        }
        
        .focus-toggle.active::after {
            content: ' (F)';
        }
        
        /* Add Building Modal */
        .add-building-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        
        .add-building-modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: none;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .add-building-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .add-building-form label {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        .add-building-form input, .add-building-form textarea {
            padding: 8px 12px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .add-building-form input:focus, .add-building-form textarea:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 5px rgba(0,123,255,0.3);
        }
        
        .form-row {
            display: flex;
            gap: 10px;
        }
        
        .form-row > div {
            flex: 1;
        }
        
        .add-building-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        
        .add-building-buttons button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #0056b3;
        }
        
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #545b62;
        }
        
        .coordinate-helper {
            font-size: 12px;
            color: #6c757d;
            margin-top: 5px;
        }
        
        /* Building Spreadsheet Modal */
        .building-list-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        
        .building-list-modal-content {
            background-color: #fefefe;
            margin: 2% auto;
            padding: 20px;
            border: none;
            border-radius: 8px;
            width: 95%;
            max-width: 1200px;
            height: 90%;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
        }
        
        .spreadsheet-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 15px;
        }
        
        .spreadsheet-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .building-table-container {
            flex: 1;
            overflow: auto;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }
        
        .building-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        .building-table th,
        .building-table td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
            border-right: 1px solid #dee2e6;
        }
        
        .building-table th {
            background-color: #f8f9fa;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
            cursor: pointer;
            user-select: none;
        }
        
        .building-table th:hover {
            background-color: #e9ecef;
        }
        
        .building-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        
        .building-table tr.checked {
            background-color: #d4edda !important;
            color: #155724;
        }
        
        .building-table tr:hover:not(.checked) {
            background-color: #e3f2fd;
        }
        
        .status-checkbox {
            transform: scale(1.2);
            cursor: pointer;
        }
        
        .cluster-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            color: white;
            min-width: 20px;
            text-align: center;
        }
        
        .sort-indicator {
            margin-left: 5px;
            opacity: 0.5;
        }
        
        .filter-row th {
            background-color: #e9ecef !important;
            padding: 4px 8px !important;
            border-bottom: 2px solid #dee2e6 !important;
        }
        
        .filter-input {
            border: 1px solid #ced4da;
            border-radius: 3px;
            outline: none;
        }
        
        .filter-input:focus {
            border-color: #007bff;
            box-shadow: 0 0 3px rgba(0,123,255,0.3);
        }
        
        /* Time-based cluster modal */
        .time-cluster-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        
        .time-cluster-modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: none;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .time-input-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }
        
        .time-input-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }
        
        .time-input {
            padding: 8px 12px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 16px;
            width: 100px;
        }
        
        .preview-section {
            margin: 20px 0;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 6px;
            border: 1px solid #2196f3;
        }
        
        .preview-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .preview-stat {
            text-align: center;
            padding: 8px;
            background: white;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        
        .preview-stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .preview-stat-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 2px;
        }
        
        .option-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .option-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .option-btn.pluck {
            background-color: #ffc107;
            color: #212529;
        }
        
        .option-btn.pluck:hover {
            background-color: #e0a800;
        }
        
        .option-btn.recalculate {
            background-color: #dc3545;
            color: white;
        }
        
        .option-btn.recalculate:hover {
            background-color: #c82333;
        }
        
        /* Checked building styles */
        .checked-building {
            background-color: #d4edda !important;
            border-left: 4px solid #28a745 !important;
        }
        
        .checked-building .building-name {
            color: #155724 !important;
        }
        
        .checked-building .building-time {
            color: #155724 !important;
        }
        
        .summary-header { flex-shrink: 0; }
        .summary-content-wrapper { flex-grow: 1; overflow-y: auto; }
        #summary h1 { font-size: 1.6em; margin-top: 0; margin-bottom: 5px; color: #2c3e50; }
        .instructions { font-size: 0.9em; color: #555; background-color: #e9ecef; padding: 10px; border-radius: 5px; margin-bottom: 15px; }
        #recalculate-btn {
            display: block; width: 100%; padding: 12px; font-size: 1.1em; font-weight: bold;
            background-color: #3498db; color: white; border: none; border-radius: 5px;
            cursor: pointer; margin-bottom: 20px; transition: background-color 0.2s;
        }
        #recalculate-btn:hover { background-color: #2980b9; }
        .cluster {
            margin-bottom: 25px; border: 1px solid #ddd; border-radius: 8px;
            padding: 15px; background-color: #ffffff; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .cluster-header {
            font-weight: bold; font-size: 1.2em; margin-bottom: 12px; padding: 8px 10px;
            border-bottom: 1px solid #eee; color: white; border-radius: 5px 5px 0 0;
        }
        .cluster ul { list-style-type: none; padding-left: 0; margin: 0; }
        .cluster li {
            padding: 8px 10px; cursor: grab; border-radius: 5px; display: flex;
            justify-content: space-between; align-items: center; border-bottom: 1px dashed #f0f0f0;
            transition: background-color 0.2s ease; position: relative;
        }
        .cluster li:last-child { border-bottom: none; }
        .cluster li:hover { background-color: #e9ecef; }
        .cluster li.dragging { opacity: 0.5; transform: rotate(2deg); }
        .cluster li.drag-over { border-top: 3px solid #007bff; }
        .cluster.drag-over { background-color: #e3f2fd; border: 2px dashed #2196f3; }
        .building-name { font-weight: 500; color: #34495e; flex-grow: 1; margin-right: 10px; }
        .building-time {
            color: #7f8c8d; font-size: 0.9em; white-space: nowrap; background-color: #f0f2f5;
            padding: 3px 6px; border-radius: 4px;
        }
        .building-controls {
            display: flex; gap: 5px; margin-left: 10px;
        }
        .edit-btn, .delete-btn {
            padding: 2px 6px; font-size: 0.7em; border: none; border-radius: 3px;
            cursor: pointer; transition: background-color 0.2s;
        }
        .edit-btn { background-color: #17a2b8; color: white; }
        .edit-btn:hover { background-color: #138496; }
        .delete-btn { background-color: #dc3545; color: white; }
        .delete-btn:hover { background-color: #c82333; }
        .drag-handle {
            cursor: grab; color: #6c757d; margin-right: 8px; font-size: 0.9em;
        }
        .drag-handle:hover { color: #495057; }
        .step-number {
            background: #007bff; color: white; border-radius: 50%; width: 24px; height: 24px;
            display: inline-flex; align-items: center; justify-content: center; font-size: 0.8em;
            font-weight: bold; margin-right: 8px; flex-shrink: 0;
        }
        .travel-segment {
            background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 4px; 
            padding: 8px; margin: 4px 0; font-size: 0.85em; color: #6c757d;
            display: flex; justify-content: space-between; align-items: center;
        }
        .travel-info {
            display: flex; align-items: center; gap: 8px;
        }
        .travel-method {
            padding: 2px 6px; border-radius: 3px; font-size: 0.75em; font-weight: bold;
        }
        .travel-walk { background: #d4edda; color: #155724; }
        .travel-drive { background: #cce5ff; color: #004085; }
        .edit-travel-btn {
            padding: 2px 6px; font-size: 0.7em; background: #6c757d; color: white;
            border: none; border-radius: 3px; cursor: pointer;
        }
        .edit-travel-btn:hover { background: #545b62; }
        .building-marker { cursor: grab !important; }
        .building-marker:active { cursor: grabbing !important; }
        .total-time {
            font-weight: bold; margin-top: 15px; text-align: right; font-size: 1.1em;
            color: #27ae60; padding-top: 10px; border-top: 1px solid #eee;
        }
        .loader-container { position: relative; width: 100%; height: 100%; }
        .loader {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            border: 8px solid #f3f3f3; border-radius: 50%; border-top: 8px solid #3498db;
            width: 60px; height: 60px; animation: spin 1s linear infinite; z-index: 1001;
            display: none; /* Hidden by default */
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* Enhanced popup styling */
        .building-popup .leaflet-popup-content-wrapper {
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .building-popup .leaflet-popup-content {
            margin: 12px 15px;
            line-height: 1.4;
        }
        
        .building-popup button:hover {
            background: #0056b3 !important;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }
        
        /* Cluster assignment select styling */
        #cluster-assignment option {
            padding: 5px 8px;
            margin: 2px 0;
        }
        
        /* Building marker visual feedback */
        .building-marker {
            transition: filter 0.2s ease;
        }
        
        .building-marker:hover {
            filter: brightness(1.1) !important;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div id="summary">
            <div class="resize-handle"></div>
            <div class="focus-mode-controls">
                <button class="focus-toggle" id="focus-toggle" title="Toggle Block Focus Mode">
                    üìã Focus
                </button>
            </div>
            <div class="summary-header">
                <h1>AED Inventory Work Blocks</h1>
                <div class="button-controls">
                    <p class="instructions">
                        The initial pin locations are estimates. <strong>Use the "Re-geocode All from Addresses" button to automatically geocode better coordinates, or click and drag any pin on the map to its correct location,</strong> then click "Recalculate Clusters" to regenerate the optimized work blocks.
                    </p>
                    <button id="recalculate-btn">Recalculate Clusters</button>
                    <button id="recalculate-times-btn" style="display: block; width: 100%; padding: 8px; font-size: 0.9em; font-weight: bold; background-color: #f39c12; color: white; border: none; border-radius: 5px; cursor: pointer; margin-bottom: 10px; transition: background-color 0.2s;">Recalculate Times Only</button>
                    
                    <button id="add-building-btn" style="display: block; width: 100%; padding: 8px; font-size: 0.9em; font-weight: bold; background-color: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; margin-bottom: 10px; transition: background-color 0.2s;">‚ûï Add New Building</button>
                    
                    <button id="building-list-btn" style="display: block; width: 100%; padding: 8px; font-size: 0.9em; font-weight: bold; background-color: #17a2b8; color: white; border: none; border-radius: 5px; cursor: pointer; margin-bottom: 10px; transition: background-color 0.2s;">üìã Building Spreadsheet</button>
                    
                    <button id="time-cluster-btn" style="display: block; width: 100%; padding: 8px; font-size: 0.9em; font-weight: bold; background-color: #fd7e14; color: white; border: none; border-radius: 5px; cursor: pointer; margin-bottom: 10px; transition: background-color 0.2s;">‚è±Ô∏è Generate Time-Based Cluster</button>
                    
                    <div style="margin-bottom: 10px; padding: 8px; background: #e8f5e8; border: 1px solid #c8e6c9; border-radius: 5px;">
                        <label style="display: flex; align-items: center; font-size: 0.9em; color: #2e7d32; cursor: pointer;">
                            <input type="checkbox" id="campus-mode" style="margin-right: 8px;">
                            üè´ Campus Mode (Use direct paths instead of street routing)
                        </label>
                        <small style="color: #555; font-size: 0.8em; margin-top: 4px; display: block;">
                            Recommended for campus environments where buildings are connected by walkways
                        </small>
                    </div>
                </div>
            </div>
            <div class="summary-content-wrapper">
                 <div class="loader-container">
                    <div id="loader" class="loader"></div>
                    <div id="summary-content"></div>
                </div>
            </div>
        </div>
        <div id="map"></div>
    </div>

    <!-- Add Building Modal -->
    <div id="add-building-modal" class="add-building-modal">
        <div class="add-building-modal-content">
            <h2 style="margin-top: 0; color: #2c3e50;">‚ûï Add New Building</h2>
            <form class="add-building-form" id="add-building-form">
                <div>
                    <label for="building-code">Building Code *</label>
                    <input type="text" id="building-code" name="code" required placeholder="e.g., NEWB">
                </div>
                
                <div>
                    <label for="building-name">Building Name *</label>
                    <input type="text" id="building-name" name="name" required placeholder="e.g., NEW BUILDING (NEWB)">
                </div>
                
                <div class="form-row">
                    <div>
                        <label for="building-gsf">GSF (Gross Square Feet)</label>
                        <input type="number" id="building-gsf" name="gsf" placeholder="0" min="0">
                    </div>
                    <div>
                        <label for="building-aed-count">AED Count *</label>
                        <input type="number" id="building-aed-count" name="aedCount" required placeholder="1" min="1" value="1">
                    </div>
                </div>
                
                <div class="form-row">
                    <div>
                        <label for="building-lat">Latitude *</label>
                        <input type="number" id="building-lat" name="lat" required placeholder="40.0074" step="any">
                        <div class="coordinate-helper">Click on the map to auto-fill coordinates</div>
                    </div>
                    <div>
                        <label for="building-lon">Longitude *</label>
                        <input type="number" id="building-lon" name="lon" required placeholder="-105.2659" step="any">
                        <div class="coordinate-helper">or enter manually</div>
                    </div>
                </div>
                
                <div>
                    <label for="building-address">Address (Optional)</label>
                    <textarea id="building-address" name="address" placeholder="Street address for geocoding" rows="2"></textarea>
                </div>
                
                <div class="add-building-buttons">
                    <button type="button" class="btn-secondary" id="cancel-add-building">Cancel</button>
                    <button type="button" class="btn-primary" id="geocode-address-btn">üìç Geocode Address</button>
                    <button type="submit" class="btn-primary">Add Building</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Building Spreadsheet Modal -->
    <div id="building-list-modal" class="building-list-modal">
        <div class="building-list-modal-content">
            <div class="spreadsheet-header">
                <h2 style="margin: 0; color: #2c3e50;">üìã Building Inventory Spreadsheet</h2>
                <div class="spreadsheet-controls">
                    <span id="building-stats" style="margin-right: 15px; color: #6c757d;"></span>
                    <button class="btn-secondary" onclick="clearAllFilters()">üîÑ Clear Filters</button>
                    <button class="btn-secondary" onclick="exportBuildingData()">üì§ Export CSV</button>
                    <button class="btn-secondary" onclick="closeBuildingSpreadsheet()">‚úï Close</button>
                </div>
            </div>
            <div class="building-table-container">
                <table class="building-table" id="building-table">
                    <thead>
                        <tr>
                            <th data-sort="checked">Status <span class="sort-indicator">‚Üï</span></th>
                            <th data-sort="code">Code <span class="sort-indicator">‚Üï</span></th>
                            <th data-sort="name">Name <span class="sort-indicator">‚Üï</span></th>
                            <th data-sort="gsf">GSF <span class="sort-indicator">‚Üï</span></th>
                            <th data-sort="aedCount">AEDs <span class="sort-indicator">‚Üï</span></th>
                            <th data-sort="cluster">Cluster <span class="sort-indicator">‚Üï</span></th>
                            <th data-sort="lat">Latitude <span class="sort-indicator">‚Üï</span></th>
                            <th data-sort="lon">Longitude <span class="sort-indicator">‚Üï</span></th>
                            <th>Actions</th>
                        </tr>
                        <tr class="filter-row">
                            <th>
                                <select id="filter-status" class="filter-input" style="width: 100%; padding: 4px; font-size: 12px;">
                                    <option value="">All Status</option>
                                    <option value="checked">Checked</option>
                                    <option value="unchecked">Unchecked</option>
                                </select>
                            </th>
                            <th><input type="text" id="filter-code" class="filter-input" placeholder="Filter code..." style="width: 100%; padding: 4px; font-size: 12px;"></th>
                            <th><input type="text" id="filter-name" class="filter-input" placeholder="Filter name..." style="width: 100%; padding: 4px; font-size: 12px;"></th>
                            <th><input type="number" id="filter-gsf" class="filter-input" placeholder="Min GSF" style="width: 100%; padding: 4px; font-size: 12px;"></th>
                            <th><input type="number" id="filter-aeds" class="filter-input" placeholder="Min AEDs" style="width: 100%; padding: 4px; font-size: 12px;"></th>
                            <th>
                                <select id="filter-cluster" class="filter-input" style="width: 100%; padding: 4px; font-size: 12px;">
                                    <option value="">All Clusters</option>
                                    <option value="Unassigned">Unassigned</option>
                                </select>
                            </th>
                            <th><input type="number" id="filter-lat" class="filter-input" placeholder="Min Lat" step="any" style="width: 100%; padding: 4px; font-size: 12px;"></th>
                            <th><input type="number" id="filter-lon" class="filter-input" placeholder="Min Lon" step="any" style="width: 100%; padding: 4px; font-size: 12px;"></th>
                            <th style="text-align: center; color: #6c757d; font-size: 12px;">Filters</th>
                        </tr>
                    </thead>
                    <tbody id="building-table-body">
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Time-Based Cluster Modal -->
    <div id="time-cluster-modal" class="time-cluster-modal">
        <div class="time-cluster-modal-content">
            <h2 style="margin-top: 0; color: #2c3e50;">‚è±Ô∏è Generate Time-Based Cluster</h2>
            <p style="color: #6c757d; margin-bottom: 20px;">Create an optimized work block for someone with limited time, using only unchecked buildings.</p>
            
            <div class="time-input-section">
                <h3 style="margin-top: 0;">Available Time</h3>
                <div class="time-input-row">
                    <label for="available-minutes">Minutes:</label>
                    <input type="number" id="available-minutes" class="time-input" placeholder="90" min="5" max="480">
                    <span style="color: #6c757d;">or</span>
                    <label for="available-hours">Hours:</label>
                    <input type="number" id="available-hours" class="time-input" placeholder="1.5" min="0.1" max="8" step="0.1">
                </div>
                <button class="btn-primary" id="calculate-cluster-btn" style="margin-top: 10px;">üîç Find Optimal Buildings</button>
            </div>
            
            <div id="cluster-preview" class="preview-section" style="display: none;">
                <h3 style="margin-top: 0;">üìä Cluster Preview</h3>
                <div class="preview-stats">
                    <div class="preview-stat">
                        <div class="preview-stat-value" id="preview-buildings">0</div>
                        <div class="preview-stat-label">Buildings</div>
                    </div>
                    <div class="preview-stat">
                        <div class="preview-stat-value" id="preview-aeds">0</div>
                        <div class="preview-stat-label">Total AEDs</div>
                    </div>
                    <div class="preview-stat">
                        <div class="preview-stat-value" id="preview-time">0</div>
                        <div class="preview-stat-label">Total Time (min)</div>
                    </div>
                    <div class="preview-stat">
                        <div class="preview-stat-value" id="preview-efficiency">0%</div>
                        <div class="preview-stat-label">Time Efficiency</div>
                    </div>
                </div>
                
                <div style="margin-top: 15px;">
                    <h4>Buildings in this cluster:</h4>
                    <div id="preview-building-list" style="max-height: 120px; overflow-y: auto; background: white; padding: 10px; border-radius: 4px; border: 1px solid #ccc;"></div>
                </div>
                
                <div class="option-buttons">
                    <button class="option-btn pluck" id="pluck-buildings-btn">
                        üì§ Pluck Buildings<br>
                        <small>Remove from existing clusters, keep others unchanged</small>
                    </button>
                    <button class="option-btn recalculate" id="full-recalc-btn">
                        üîÑ Full Recalculation<br>
                        <small>Create cluster and recalculate all remaining buildings</small>
                    </button>
                </div>
            </div>
            
            <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
                <button class="btn-secondary" id="cancel-time-cluster-btn">Cancel</button>
            </div>
        </div>
    </div>

<script>
// --- FULLY GEOCODED & CONSOLIDATED BUILDING DATA ---
const buildingData = [
    { code: "1135BRD", name: "1135 BROADWAY (1135BRD)", gsf: 18408, aedCount: 3, lat: 40.00947, lon: -105.28172 },
    { code: "122126TH", name: "1221 26TH STREET", gsf: 2754, aedCount: 3, lat: 40.01525, lon: -105.26359 },
    { code: "1301WA", name: "1301 WALNUT ST (1301WA)", gsf: 4226, aedCount: 3, lat: 40.01755, lon: -105.27855 },
    { code: "1506BRD", name: "1506 BROADWAY (1506BRD)", gsf: 10977, aedCount: 3, lat: 40.0101, lon: -105.27552 },
    { code: "1522BRD", name: "1522 BROADWAY (1522BRD)", gsf: 3491, aedCount: 3, lat: 40.01, lon: -105.27533 },
    { code: "2360ARP", name: "ROB'S AUTO REPAIR (2360ARP)", gsf: 0, aedCount: 3, lat: 40.0178, lon: -105.26252 },
    { code: "2390PRL", name: "2930 PEARL STREET (2390PRL)", gsf: 0, aedCount: 1, lat: 40.0242, lon: -105.2571 },
    { code: "2705CLR", name: "2705 COLORADO", gsf: 1603, aedCount: 3, lat: 40.0081, lon: -105.25877 },
    { code: "3100ARP", name: "PARK PLACE (3100ARP)", gsf: 15022, aedCount: 1, lat: 40.01742, lon: -105.25301 },
    { code: "5425AIR", name: "5425 AIRPORT ROAD (5425AIR)", gsf: 6962, aedCount: 3, lat: 40.04018, lon: -105.2343 },
    { code: "5555CNT", name: "5555 CENTRAL AVENUE (5555CNT)", gsf: 0, aedCount: 1, lat: 40.0195, lon: -105.2282 },
    { code: "721EMRY", name: "GUARDIAN STORAGE LONGMONT (721EMRY)", gsf: 820, aedCount: 3, lat: 40.15852, lon: -105.1054 },
    { code: "ABSA", name: "ABSAROKA (ABSA)", gsf: 126, aedCount: 3, lat: 39.9926, lon: -105.5457 },
    { code: "ADEN", name: "ADEN HALL (ADEN)", gsf: 26941, aedCount: 1, lat: 40.00331, lon: -105.26266 },
    { code: "AERO", name: "AEROSPACE ENGINEERING SCIENCES (AERO)", gsf: 185868, aedCount: 1, lat: 40.0135, lon: -105.2427 },
    { code: "ALMG", name: "ALUMNI CENTER GARAGE ANNEX (ALMG)", gsf: 1200, aedCount: 3, lat: 40.00913, lon: -105.27896 },
    { code: "ALUM", name: "KOENIG ALUMNI CENTER (ALUM)", gsf: 9781, aedCount: 1, lat: 40.00913, lon: -105.27896 },
    { code: "ANDS", name: "ANDREWS HALL (ANDS)", gsf: 61827, aedCount: 3, lat: 40.0053, lon: -105.2616 },
    { code: "ARCE", name: "ADMINISTRATIVE AND RESEARCH CENTER- EAST CAMPUS (ARCE)", gsf: 186279, aedCount: 3, lat: 40.01391, lon: -105.25389 },
    { code: "ARCEA", name: "ADMINISTRATIVE AND RESEARCH CENTER MECHANICAL BUILDING (ARCEA)", gsf: 131, aedCount: 3, lat: 40.01391, lon: -105.25389 },
    { code: "ARL", name: "ASTROPHYSICAL RESEARCH LABORATORY (ARL)", gsf: 34435, aedCount: 1, lat: 40.01235, lon: -105.2472 },
    { code: "ARMR", name: "ARMORY (ARMR)", gsf: 24976, aedCount: 1, lat: 40.0098, lon: -105.273 },
    { code: "ARNT", name: "ARNETT HALL (ARNT)", gsf: 61574, aedCount: 1, lat: 40.0049, lon: -105.2605 },
    { code: "ASPN", name: "ASPEN (ASPN)", gsf: 506, aedCount: 3, lat: 39.9926, lon: -105.5457 },
    { code: "ATCTA1", name: "ATHENS COURT A1 (ATCTA1)", gsf: 7488, aedCount: 3, lat: 40.01389, lon: -105.27202 },
    { code: "ATCTA2", name: "ATHENS COURT A2 (ATCTA2)", gsf: 7488, aedCount: 1, lat: 40.0139, lon: -105.2713 },
    { code: "ATCTA3", name: "ATHENS COURT A3 (ATCTA3)", gsf: 7488, aedCount: 1, lat: 40.0134, lon: -105.2714 },
    { code: "ATCTA4", name: "ATHENS COURT A4 (ATCTA4)", gsf: 7488, aedCount: 1, lat: 40.0133, lon: -105.2722 },
    { code: "ATCTB1", name: "ATHENS COURT B1 (ATCTB1)", gsf: 8923, aedCount: 1, lat: 40.0143, lon: -105.2727 },
    { code: "ATCTB2", name: "ATHENS COURT B2 (ATCTB2)", gsf: 8923, aedCount: 1, lat: 40.0139, lon: -105.2704 },
    { code: "ATCTB3", name: "ATHENS COURT B3 (ATCTB3)", gsf: 8923, aedCount: 1, lat: 40.0136, lon: -105.2693 },
    { code: "ATCTC1", name: "ATHENS COURT C1 (ATCTC1)", gsf: 9836, aedCount: 1, lat: 40.0137, lon: -105.2699 },
    { code: "ATCTC2", name: "ATHENS COURT C2 (ATCTC2)", gsf: 10144, aedCount: 1, lat: 40.0129, lon: -105.2701 },
    { code: "ATCTM1", name: "ATHENS COURT MAIL 1 (ATCTM1)", gsf: 97, aedCount: 3, lat: 40.01334, lon: -105.27218 },
    { code: "ATCTM2", name: "ATHENS COURT MAIL 2 (ATCTM2)", gsf: 97, aedCount: 1, lat: 40.01334, lon: -105.27218 },
    { code: "ATCTS1", name: "ATHENS COURT STORAGE 1 (ATCTS1)", gsf: 97, aedCount: 1, lat: 40.01334, lon: -105.27218 },
    { code: "ATCTS2", name: "ATHENS COURT STORAGE 2 (ATCTS2)", gsf: 97, aedCount: 1, lat: 40.01334, lon: -105.27218 },
    { code: "ATCTS3", name: "ATHENS COURT STORAGE 3 (ATCTS3)", gsf: 97, aedCount: 1, lat: 40.01334, lon: -105.27218 },
    { code: "ATCTT1", name: "ATHENS COURT TELECOM 1 (ATCTT1)", gsf: 97, aedCount: 1, lat: 40.01334, lon: -105.27218 },
    { code: "ATHN", name: "ATHENS NORTH COURT (ATHN)", gsf: 52183, aedCount: 1, lat: 40.0134, lon: -105.2737 },
    { code: "ATLS", name: "ROSER ATLAS CENTER (ATLS)", gsf: 72739, aedCount: 1, lat: 40.00762, lon: -105.27117 },
    { code: "BATH", name: "BATH HOUSE (BATH)", gsf: 656, aedCount: 3, lat: 39.9926, lon: -105.5457 },
    { code: "BCAPB", name: "BEAR CREEK APT B (BCAPB)", gsf: 190886, aedCount: 1, lat: 39.99849, lon: -105.25471 },
    { code: "BCAT", name: "BOBCAT (BCAT)", gsf: 127, aedCount: 3, lat: 39.9926, lon: -105.5457 },
    { code: "BESC", name: "BENSON EARTH SCIENCES BUILDING (BESC)", gsf: 89647, aedCount: 1, lat: 40.0073, lon: -105.2635 },
    { code: "BHRN", name: "BIGHORN (BHRN)", gsf: 127, aedCount: 3, lat: 39.9926, lon: -105.5457 },
    { code: "BIOT", name: "JENNIE SMOLY CARUTHERS BIOTECHNOLOGY BUILDING (BIOT)", gsf: 416570, aedCount: 1, lat: 40.0118, lon: -105.2483 },
    { code: "BISN", name: "BISON (BISN)", gsf: 127, aedCount: 3, lat: 39.9926, lon: -105.5457 },
    { code: "BKER", name: "BAKER HALL (BKER)", gsf: 113238, aedCount: 3, lat: 40.0051, lon: -105.2685 },
    { code: "BLWR", name: "BLOWER BUILDING (BLWR)", gsf: 54, aedCount: 3, lat: 39.9926, lon: -105.5457 },
    { code: "BREG", name: "BICYCLE REGISTRATION BUILDING (BREG)", gsf: 60, aedCount: 3, lat: 40.0068, lon: -105.2736 },
    { code: "BRKT", name: "BRACKETT HALL (BRKT)", gsf: 26901, aedCount: 1, lat: 40.0031, lon: -105.2621 },
    { code: "BUCK", name: "BUCKINGHAM HALL (BUCK)", gsf: 60221, aedCount: 1, lat: 40.0046, lon: -105.2598 },
    { code: "C4C", name: "CENTER FOR COMMUNITY (C4C)", gsf: 320785, aedCount: 2, lat: 40.00396, lon: -105.2644 },
    { code: "CARL", name: "CARLSON GYMNASIUM (CARL)", gsf: 58232, aedCount: 1, lat: 40.0063, lon: -105.2694 },
    { code: "CARP", name: "CARPENTER SHOP (CARP)", gsf: 1234, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "CASE", name: "CENTER FOR ACADEMIC SUCCESS AND ENGAGEMENT (CASE)", gsf: 248460, aedCount: 1, lat: 40.0076, lon: -105.2724 },
    { code: "CCH", name: "LIMELIGHT CONFERENCE CENTER & HOTEL (CCH)", gsf: 0, aedCount: 1, lat: 40.0104, lon: -105.2778 },
    { code: "CCHG", name: "LIMELIGHT CONFERENCE CENTER & HOTEL GARAGE (CCHG)", gsf: 0, aedCount: 1, lat: 40.0108, lon: -105.2783 },
    { code: "CEDU", name: "CONTINUING EDUCATION CENTER (CEDU)", gsf: 19347, aedCount: 1, lat: 40.01, lon: -105.2735 },
    { code: "CHEM", name: "CRISTOL CHEMISTRY & BIOCHEMISTRY BUILDING (CHEM)", gsf: 148716, aedCount: 1, lat: 40.0084, lon: -105.2735 },
    { code: "CHEY", name: "CHEYENNE ARAPAHO HALL (CHEY)", gsf: 110628, aedCount: 1, lat: 40.0028, lon: -105.2657 },
    { code: "CHKD", name: "CHICKADEE (CHKD)", gsf: 124, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "CHKR", name: "CHICKAREE (CHKR)", gsf: 138, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "CHMP", name: "UCHEALTH CHAMPIONS CENTER (CHMP)", gsf: 231119, aedCount: 8, lat: 40.0097, lon: -105.265 },
    { code: "CHST", name: "CHEMICAL STORAGE BUILDING (CHST)", gsf: 165, aedCount: 3, lat: 40.0044, lon: -105.2649 },
    { code: "CINC", name: "CENTER FOR INNOVATION & CREATIVITY (CINC)", gsf: 87183, aedCount: 1, lat: 40.01685, lon: -105.24647 },
    { code: "CINCP", name: "CENTER FOR INNOVATION & CREATIVITY PAVILION (CINCP)", gsf: 1648, aedCount: 1, lat: 40.01685, lon: -105.24647 },
    { code: "CIRE", name: "CIRES COOPERATIVE INSTITUTE FOR RESEARCH IN ENVIRONMENTAL SCIENCES (CIRE)", gsf: 28657, aedCount: 1, lat: 40.008, lon: -105.2733 },
    { code: "CKRL", name: "COCKERELL HALL (CKRL)", gsf: 25372, aedCount: 1, lat: 40.0035, lon: -105.2619 },
    { code: "CLMB", name: "COLUMBINE (CLMB)", gsf: 770, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "CLRE", name: "CLARE SMALL ARTS & SCIENCES (CLRE)", gsf: 43373, aedCount: 1, lat: 40.007, lon: -105.2701 },
    { code: "CLUB", name: "UNIVERSITY CLUB (CLUB)", gsf: 28197, aedCount: 1, lat: 40.0082, lon: -105.281 },
    { code: "COMP", name: "COMPUTING CENTER (COMP)", gsf: 28880, aedCount: 1, lat: 40.0135, lon: -105.2495 },
    { code: "COTT", name: "GATES WOODRUFF WOMEN'S STUDIES COTTAGE (COTT)", gsf: 5229, aedCount: 1, lat: 40.0099, lon: -105.2811 },
    { code: "COYO", name: "COYOTE (COYO)", gsf: 127, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "CPMP", name: "COLORADO POND PUMP STATION (CPMP)", gsf: 478, aedCount: 1, lat: 40.0081, lon: -105.25877 },
    { code: "CROS", name: "CROSMAN HALL (CROS)", gsf: 25936, aedCount: 1, lat: 40.004, lon: -105.2678 },
    { code: "DACR", name: "CU CHILDREN'S CENTER (DACR)", gsf: 4129, aedCount: 1, lat: 40.0163, lon: -105.2651 },
    { code: "DACRA", name: "CU CHILDREN'S CENTER (DACRA)", gsf: 2360, aedCount: 1, lat: 40.0163, lon: -105.2651 },
    { code: "DACRB", name: "CU CHILDREN'S CENTER (DACRB)", gsf: 189, aedCount: 1, lat: 40.0163, lon: -105.2651 },
    { code: "DALW", name: "DAL WARD ATHLETIC CENTER (DALW)", gsf: 100749, aedCount: 5, lat: 40.0104, lon: -105.266 },
    { code: "DDW", name: "DUANE D-WING (DDW)", gsf: 31997, aedCount: 3, lat: 40.0075, lon: -105.267 },
    { code: "DEN", name: "DENISON ARTS & SCIENCES BUILDING (DEN)", gsf: 5471, aedCount: 1, lat: 40.0097, lon: -105.2825 },
    { code: "DHLL", name: "DINING HALL (DHLL)", gsf: 2452, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "DLC", name: "GALLOGLY DISCOVERY LEARNING CENTER (DLC)", gsf: 59745, aedCount: 1, lat: 40.0051, lon: -105.2662 },
    { code: "DRLN", name: "DARLEY TOWERS NORTH (DRLN)", gsf: 72423, aedCount: 1, lat: 40.002, lon: -105.257 },
    { code: "DRLS", name: "DARLEY TOWERS SOUTH (DRLS)", gsf: 50541, aedCount: 1, lat: 40.0016, lon: -105.257 },
    { code: "DUAN", name: "DUANE PHYSICS (DUAN)", gsf: 195233, aedCount: 2, lat: 40.0076, lon: -105.2664 },
    { code: "ECAD", name: "ENGINEERING ADMINISTRATION WING (ECAD)", gsf: 18817, aedCount: 3, lat: 40.0068, lon: -105.2638 },
    { code: "ECCE", name: "ENGINEERING CIVIL & ENVIRONMENTAL WING (ECCE)", gsf: 71932, aedCount: 3, lat: 40.0068, lon: -105.2638 },
    { code: "ECCR", name: "ENGINEERING CLASSROOM WING (ECCR)", gsf: 63929, aedCount: 3, lat: 40.0068, lon: -105.2638 },
    { code: "ECCS", name: "ENGINEERING COMPUTER SCIENCE DEPT (ECCS)", gsf: 36859, aedCount: 3, lat: 40.0068, lon: -105.2638 },
    { code: "ECEE", name: "ENGINEERING ELECTRICAL WING (ECEE)", gsf: 112348, aedCount: 3, lat: 40.0068, lon: -105.2638 },
    { code: "ECES", name: "ENVIRONMENTAL SUSTAINABILITY WING (ECES)", gsf: 51836, aedCount: 3, lat: 40.0068, lon: -105.2638 },
    { code: "ECGBA", name: "EAST CAMPUS GROUNDS BUILDING A (ECGBA)", gsf: 294, aedCount: 1, lat: 40.0129, lon: -105.2519 },
    { code: "ECGBB", name: "EAST CAMPUS GROUNDS BUILDING B (ECGBB)", gsf: 483, aedCount: 1, lat: 40.0129, lon: -105.2519 },
    { code: "ECGBC", name: "EAST CAMPUS GROUNDS BUILDING C (ECGBC)", gsf: 294, aedCount: 1, lat: 40.0129, lon: -105.2519 },
    { code: "ECGBD", name: "EAST CAMPUS GROUNDS BUILDING D (ECGBD)", gsf: 294, aedCount: 1, lat: 40.0129, lon: -105.2519 },
    { code: "ECME", name: "ENGINEERING MECHANICAL WING (ECME)", gsf: 51762, aedCount: 3, lat: 40.0068, lon: -105.2638 },
    { code: "ECNT", name: "ENGINEERING NORTH TOWER (ECNT)", gsf: 18156, aedCount: 1, lat: 40.0068, lon: -105.2638 },
    { code: "ECNW", name: "ENGINEERING CENTER NORTH WING (ECNW)", gsf: 40692, aedCount: 1, lat: 40.0068, lon: -105.2638 },
    { code: "ECON", name: "ECONOMICS BUILDING (ECON)", gsf: 29605, aedCount: 1, lat: 40.0084, lon: -105.2754 },
    { code: "ECOT", name: "ENGINEERING OFFICE TOWER (ECOT)", gsf: 90249, aedCount: 1, lat: 40.0068, lon: -105.2638 },
    { code: "ECPDC", name: "EAST CAMPUS POWER DISTRIBUTION CENTER (ECPDC)", gsf: 1491, aedCount: 1, lat: 40.0122, lon: -105.2516 },
    { code: "ECSL", name: "ENGINEERING STORES & LABS (ECSL)", gsf: 12274, aedCount: 1, lat: 40.0068, lon: -105.2638 },
    { code: "ECST", name: "ENGINEERING SOUTH TOWER (ECST)", gsf: 16906, aedCount: 1, lat: 40.0068, lon: -105.2638 },
    { code: "EDEP", name: "EAST DISTRICT ENERGY PLANT (EDEP)", gsf: 56546, aedCount: 1, lat: 40.004, lon: -105.2655 },
    { code: "EHSC", name: "ENVIRONMENTAL HEALTH & SAFETY (EHSC)", gsf: 22270, aedCount: 1, lat: 40.0044, lon: -105.264 },
    { code: "EKLC", name: "EKELEY SCIENCES BUILDING (EKLC)", gsf: 133996, aedCount: 1, lat: 40.0087, lon: -105.2741 },
    { code: "ELSH", name: "ELECTRIC SHOP (ELSH)", gsf: 232, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "EMGBA", name: "EAST MAIN GROUNDS BUILDING A (EMGBA)", gsf: 295, aedCount: 1, lat: 40.005, lon: -105.2656 },
    { code: "EMGBB", name: "EAST MAIN GROUNDS BUILDING B (EMGBB)", gsf: 294, aedCount: 1, lat: 40.005, lon: -105.2656 },
    { code: "ENVD", name: "ENVIRONMENTAL DESIGN BUILDING (ENVD)", gsf: 60412, aedCount: 1, lat: 40.0065, lon: -105.2745 },
    { code: "EVNT", name: "CU EVENTS CENTER (EVNT)", gsf: 194226, aedCount: 2, lat: 40.0049, lon: -105.264 },
    { code: "FBST", name: "FOLSOM BIKE STATION (FBST)", gsf: 347, aedCount: 1, lat: 40.005, lon: -105.2677 },
    { code: "FH", name: "BALCH FIELDHOUSE COMPLEX (FH)", gsf: 69161, aedCount: 3, lat: 40.008, lon: -105.268 },
    { code: "FHPB", name: "BALCH FIELDHOUSE PRESSBOX (FHPB)", gsf: 20247, aedCount: 1, lat: 40.008, lon: -105.268 },
    { code: "FIRE", name: "FIRE SPRINKLER BUILDING (FIRE)", gsf: 62, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "FISK", name: "FISKE PLANETARIUM & SCIENCE CENTER (FISK)", gsf: 16768, aedCount: 1, lat: 40.0043, lon: -105.2615 },
    { code: "FLYC", name: "FLYCATCHER (FLYC)", gsf: 124, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "FNCH", name: "FINCH (FNCH)", gsf: 126, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "FRND", name: "FARRAND HALL (FRND)", gsf: 132552, aedCount: 3, lat: 40.0044, lon: -105.267 },
    { code: "FS1", name: "FACULTY STAFF COURT 1 (FS1)", gsf: 3574, aedCount: 1, lat: 40.0126, lon: -105.2723 },
    { code: "FS2", name: "FACULTY STAFF COURT 2 (FS2)", gsf: 3574, aedCount: 1, lat: 40.0131, lon: -105.2732 },
    { code: "FS4", name: "FACULTY STAFF COURT 4 (FS4)", gsf: 3574, aedCount: 1, lat: 40.0124, lon: -105.2721 },
    { code: "FS8", name: "FACULTY STAFF COURT 8 (FS8)", gsf: 3574, aedCount: 1, lat: 40.0133, lon: -105.2739 },
    { code: "FS9", name: "FACULTY STAFF COURT 9 (FS9)", gsf: 3566, aedCount: 1, lat: 40.0131, lon: -105.2736 },
    { code: "GASR", name: "GAS REGULATOR BUILDING (GASR)", gsf: 918, aedCount: 1, lat: 40.0079, lon: -105.2585 },
    { code: "GCOT", name: "THE GRANDVIEW COTTAGE (GCOT)", gsf: 3886, aedCount: 3, lat: 40.011, lon: -105.2778 },
    { code: "GH-1", name: "GREENHOUSE NO 1 AT MACKY (GH-1)", gsf: 3299, aedCount: 3, lat: 40.0097, lon: -105.275 },
    { code: "GH-3", name: "RESEARCH PARK GREENHOUSE (GH-3)", gsf: 10324, aedCount: 3, lat: 40.0135, lon: -105.251 },
    { code: "GNHS", name: "MOUNTAIN RESEARCH GREENHOUSE (GNHS)", gsf: 160, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "GNSH", name: "GENERATOR SHED (GNSH)", gsf: 144, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "GOLD", name: "GOLD BIOSCIENCES BUILDING (GOLD)", gsf: 132267, aedCount: 1, lat: 40.0076, lon: -105.2685 },
    { code: "GONG", name: "NSO GONG BUILDING (GONG)", gsf: 480, aedCount: 1, lat: 40.015, lon: -105.244 },
    { code: "GRGE", name: "GARAGE (GRGE)", gsf: 731, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "GROC", name: "GROUNDS AND RECYCLING OPERATIONS CENTER (GROC)", gsf: 19318, aedCount: 1, lat: 40.0043, lon: -105.2651 },
    { code: "GROU", name: "GROUSE (GROU)", gsf: 126, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "GRSH", name: "GARAGE SHED (GRSH)", gsf: 162, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "GSHK", name: "GOSHAWK (GSHK)", gsf: 125, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "GSREC", name: "GAS REGULATOR BUILDING EAST CAMPUS (GSREC)", gsf: 187, aedCount: 1, lat: 40.0146, lon: -105.2452 },
    { code: "GUGG", name: "GUGGENHEIM GEOGRAPHY BUILDING (GUGG)", gsf: 22909, aedCount: 1, lat: 40.0083, lon: -105.275 },
    { code: "GVAS", name: "1330/1332 GRANDVIEW (GVAS)", gsf: 1776, aedCount: 3, lat: 40.0115, lon: -105.2774 },
    { code: "HALE", name: "HALE SCIENCE BUILDING (HALE)", gsf: 41791, aedCount: 1, lat: 40.0082, lon: -105.2775 },
    { code: "HAZM", name: "HAZMAT SHED (HAZM)", gsf: 82, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "HEND", name: "HENDERSON BUILDING (MUSEUM)", gsf: 31238, aedCount: 3, lat: 40.0094, lon: -105.2811 },
    { code: "HFOC", name: "HOUSING & DINING SERVICES FACILITES OPERATIONS (HFOC)", gsf: 38581, aedCount: 1, lat: 40.0133, lon: -105.2505 },
    { code: "HLET", name: "HALLETT HALL (HLET)", gsf: 98234, aedCount: 1, lat: 40.0035, lon: -105.264 },
    { code: "HLMS", name: "HELLEMS ARTS & SCIENCES BUILDING (HLMS)", gsf: 117625, aedCount: 3, lat: 40.0077, lon: -105.2745 },
    { code: "HPCF", name: "HIGH PERFORMANCE COMPUTING FACILITY (HPCF)", gsf: 2312, aedCount: 1, lat: 40.01685, lon: -105.24647 },
    { code: "HSSC", name: "HOUSING SYSTEM SERVICE CENTER (HSSC)", gsf: 39015, aedCount: 1, lat: 40.0125, lon: -105.2507 },
    { code: "HUMM", name: "HUMMINGBIRD (HUMM)", gsf: 126, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "HUMN", name: "EATON HUMANITIES BUILDING (HUMN)", gsf: 61492, aedCount: 1, lat: 40.0075, lon: -105.2736 },
    { code: "IBG", name: "INSTITUTE FOR BEHAVIORAL GENETICS (IBG)", gsf: 25741, aedCount: 3, lat: 40.0143, lon: -105.252 },
    { code: "IEC", name: "INTERNATIONAL ENGLISH CENTER (IEC)", gsf: 13075, aedCount: 3, lat: 40.0163, lon: -105.279 },
    { code: "INFO", name: "COLLEGE OF MEDIA, COMMUNICATION AND INFORMATION DEPARTMENT OF INFORMATION SCIENCE (INFO)", gsf: 16773, aedCount: 3, lat: 40.006, lon: -105.2736 },
    { code: "IPRC", name: "INDOOR PRACTICE FACILITY (IPRC)", gsf: 328098, aedCount: 1, lat: 40.009, lon: -105.2655 },
    { code: "ITLL", name: "DRESCHER UNDERGRADUATE ENGINEERING INTEGRATED TEACHING AND LEARNING LAB (ITLL)", gsf: 37115, aedCount: 1, lat: 40.005, lon: -105.267 },
    { code: "JAY", name: "JAY (JAY)", gsf: 117, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "JESS", name: "RICHARD JESSOR BUILDING (JESS)", gsf: 57869, aedCount: 3, lat: 40.0104, lon: -105.2749 },
    { code: "JILA", name: "JILA (JILA)", gsf: 160974, aedCount: 6, lat: 40.0075, lon: -105.2675 },
    { code: "JNCO", name: "JUNCO (JNCO)", gsf: 124, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "KCEN", name: "KITTREDGE CENTRAL (KCEN)", gsf: 100743, aedCount: 3, lat: 40.0051, lon: -105.2621 },
    { code: "KCHN", name: "KITCHEN (KCHN)", gsf: 402, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "KCNC", name: "KITCHEN COOLER (KCNC)", gsf: 136, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "KIOW", name: "KIOWA LAB (KIOW)", gsf: 2967, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "KITW", name: "KITTREDGE WEST HALL (KITW)", gsf: 73810, aedCount: 3, lat: 40.0055, lon: -105.263 },
    { code: "KOBL", name: "KOELBEL BUILDING - LEEDS SCHOOL OF BUSINESS (KOBL)", gsf: 202086, aedCount: 1, lat: 40.0049, lon: -105.265 },
    { code: "KTCH", name: "KETCHUM ARTS & SCIENCES BUILDING (KTCH)", gsf: 57765, aedCount: 1, lat: 40.0072, lon: -105.2724 },
    { code: "KVCU", name: "KVCU RADIO TOWER (KVCU)", gsf: 128, aedCount: 1, lat: 39.9829, lon: -105.269 },
    { code: "LBB", name: "LUCILE BERKELEY BUCHANAN BUILDING (LBB)", gsf: 46496, aedCount: 1, lat: 40.008, lon: -105.275 },
    { code: "LDAR", name: "CIRES LIDAR FACILITY (LDAR)", gsf: 0, aedCount: 1, lat: 39.8164, lon: -105.289 },
    { code: "LESS", name: "LESSER HOUSE (LESS)", gsf: 3454, aedCount: 1, lat: 40.0078, lon: -105.2608 },
    { code: "LIBR", name: "NORLIN LIBRARY (LIBR)", gsf: 337455, aedCount: 1, lat: 40.0075, lon: -105.2718 },
    { code: "LIBY", name: "LIBBY HALL (LIBY)", gsf: 109310, aedCount: 1, lat: 40.0044, lon: -105.266 },
    { code: "LITR", name: "LITMAN RESEARCH LAB (RL1) (LITR)", gsf: 53923, aedCount: 1, lat: 40.0147, lon: -105.253 },
    { code: "LMBR", name: "LIMBER (LMBR)", gsf: 577, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "LSRL", name: "LIFE SCIENCE RESEARCH LAB (RL4) (LSRL)", gsf: 11982, aedCount: 1, lat: 40.0146, lon: -105.254 },
    { code: "LSTR", name: "LASP SPACE TECHNOLOGY RESEARCH CENTER (LSTR)", gsf: 117377, aedCount: 1, lat: 40.0142, lon: -105.245 },
    { code: "MAIN", name: "OLD MAIN (MAIN)", gsf: 28702, aedCount: 2, lat: 40.008, lon: -105.274 },
    { code: "MARR", name: "MARR ALPINE LABORATORY (MARR)", gsf: 6563, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "MATH", name: "MATHEMATICS BUILDING (MATH)", gsf: 63909, aedCount: 1, lat: 40.0072, lon: -105.263 },
    { code: "MBE", name: "OFELIA MIRAMONTES AND LEONARD BACA EDUCATION BUILDING (MBE)", gsf: 127440, aedCount: 1, lat: 40.0055, lon: -105.262 },
    { code: "MCFL", name: "MOORES COLLINS FAMILY LODGE (MCFL)", gsf: 4447, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "MCKY", name: "MACKY AUDITORIUM (MCKY)", gsf: 89119, aedCount: 2, lat: 40.0089, lon: -105.2735 },
    { code: "MCOL", name: "BRUCE CURTIS BUILDING (MCOL)", gsf: 43409, aedCount: 3, lat: 40.0086, lon: -105.2756 },
    { code: "MCPDC", name: "MAIN CAMPUS POWER DISTRIBUTION (MCPDC)", gsf: 2082, aedCount: 1, lat: 40.0068, lon: -105.2638 },
    { code: "MGRN", name: "MEGARON CLASSROOM (MGRN)", gsf: 910, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "MKNA", name: "MCKENNA LANGUAGES BUILDING (MKNA)", gsf: 23113, aedCount: 1, lat: 40.0079, lon: -105.275 },
    { code: "MRCTA", name: "MARINE COURT A (MRCTA)", gsf: 39562, aedCount: 1, lat: 40.0135, lon: -105.2707 },
    { code: "MRCTB", name: "MARINE COURT B (MRCTB)", gsf: 11048, aedCount: 1, lat: 40.0135, lon: -105.2707 },
    { code: "MRCTC", name: "MARINE COURT C (MRCTC)", gsf: 2720, aedCount: 1, lat: 40.0135, lon: -105.2707 },
    { code: "MRCTD", name: "MARINE COURT D (MRCTD)", gsf: 4160, aedCount: 1, lat: 40.0135, lon: -105.2707 },
    { code: "MRCTE", name: "MARINE COURT E (MRCTE)", gsf: 4980, aedCount: 1, lat: 40.0135, lon: -105.2707 },
    { code: "MRCTF", name: "MARINE COURT F (MRCTF)", gsf: 3338, aedCount: 1, lat: 40.0135, lon: -105.2707 },
    { code: "MRCTG", name: "MARINE COURT G (MRCTG)", gsf: 11874, aedCount: 1, lat: 40.0135, lon: -105.2707 },
    { code: "MRCTH", name: "MARINE COURT H (MRCTH)", gsf: 11090, aedCount: 1, lat: 40.0135, lon: -105.2707 },
    { code: "MRCTJ", name: "MARINE COURT J (MRCTJ)", gsf: 11874, aedCount: 1, lat: 40.0135, lon: -105.2707 },
    { code: "MRCTK", name: "MARINE COURT K (MRCTK)", gsf: 11322, aedCount: 1, lat: 40.0135, lon: -105.2707 },
    { code: "MRCTM", name: "MARINE COURT MAIL (MRCTM)", gsf: 324, aedCount: 1, lat: 40.0135, lon: -105.2707 },
    { code: "MRMT", name: "MARMOT (MRMT)", gsf: 126, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "MRTN", name: "MERTENSIA (MRTN)", gsf: 469, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "MSSC", name: "MARINE STREET SCIENCE CENTER (RL6) (MSSC)", gsf: 50512, aedCount: 3, lat: 40.013, lon: -105.253 },
    { code: "MUEN", name: "MUENZINGER PSYCHOLOGY & NUEROSCIENCE BUILDING (MUEN)", gsf: 152413, aedCount: 1, lat: 40.0076, lon: -105.268 },
    { code: "MUS", name: "IMIG MUSIC BUILDING (MUS)", gsf: 158620, aedCount: 1, lat: 40.006, lon: -105.274 },
    { code: "NBB590A", name: "NBB--SEEC SKYWATCH (NBB590A)", gsf: 182, aedCount: 1, lat: 40.015, lon: -105.244 },
    { code: "NBB699A", name: "NBB--BEAR CREEK SHED 1 (NBB699A)", gsf: 87, aedCount: 1, lat: 39.99849, lon: -105.25471 },
    { code: "NBB699B", name: "NBB--BEAR CREEK SHED 2 (NBB699B)", gsf: 47, aedCount: 1, lat: 39.99849, lon: -105.25471 },
    { code: "NBB799A", name: "NBB--CAMPUS SHELTER SOUTH PROP (NBB799A)", gsf: 600, aedCount: 1, lat: 39.9765, lon: -105.254 },
    { code: "NPL", name: "NEW PHYSICS LABORATORY (NPL)", gsf: 27537, aedCount: 1, lat: 40.0132, lon: -105.251 },
    { code: "NTCR", name: "NUTCRACKER (NTCR)", gsf: 127, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "NTCT1A", name: "NEWTON COURT 1A (NTCT1A)", gsf: 27036, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT1B", name: "NEWTON COURT 1B (NTCT1B)", gsf: 27033, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2A", name: "NEWTON COURT 2A (NTCT2A)", gsf: 8767, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2B", name: "NEWTON COURT 2B (NTCT2B)", gsf: 8466, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2C", name: "NEWTON COURT 2C (NTCT2C)", gsf: 8454, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2D", name: "NEWTON COURT 2D (NTCT2D)", gsf: 8454, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2E", name: "NEWTON COURT 2E (NTCT2E)", gsf: 8454, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2F", name: "NEWTON COURT 2F (NTCT2F)", gsf: 8481, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2G", name: "NEWTON COURT 2G (NTCT2G)", gsf: 8773, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2H", name: "NEWTON COURT 2H (NTCT2H)", gsf: 8478, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2J", name: "NEWTON COURT 2J (NTCT2J)", gsf: 8481, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2K", name: "NEWTON COURT 2K (NTCT2K)", gsf: 8481, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2L", name: "NEWTON COURT 2L (NTCT2L)", gsf: 8471, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2M", name: "NEWTON COURT 2M (NTCT2M)", gsf: 8454, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2N", name: "NEWTON COURT 2N (NTCT2N)", gsf: 8453, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2P", name: "NEWTON COURT 2P (NTCT2P)", gsf: 8454, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2R", name: "NEWTON COURT 2R (NTCT2R)", gsf: 8454, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2S", name: "NEWTON COURT 2S (NTCT2S)", gsf: 8454, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2T", name: "NEWTON COURT 2T (NTCT2T)", gsf: 8454, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2U", name: "NEWTON COURT 2U (NTCT2U)", gsf: 8454, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2V", name: "NEWTON COURT 2V (NTCT2V)", gsf: 8454, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2W", name: "NEWTON COURT 2W (NTCT2W)", gsf: 8454, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2X", name: "NEWTON COURT 2X (NTCT2X)", gsf: 8454, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCT2Y", name: "NEWTON COURT 2Y (NTCT2Y)", gsf: 8454, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCTA", name: "NEWTON COURT BOILER A (NTCTA)", gsf: 151, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCTAB", name: "NEWTON COURT BOILER AB (NTCTAB)", gsf: 132, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCTB", name: "NEWTON COURT BOILER B (NTCTB)", gsf: 226, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCTCD", name: "NEWTON COURT BOILER CD (NTCTCD)", gsf: 132, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCTEF", name: "NEWTON COURT BOILER EF (NTCTEF)", gsf: 132, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCTGH", name: "NEWTON COURT BOILER GH (NTCTGH)", gsf: 132, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCTJK", name: "NEWTON COURT BOILER JK (NTCTJK)", gsf: 132, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCTL2", name: "NEWTON COURT L2 (NTCTL2)", gsf: 834, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCTL3", name: "NEWTON COURT L3 (NTCTL3)", gsf: 1157, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCTLM", name: "NEWTON COURT BOILER LM (NTCTLM)", gsf: 132, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCTNP", name: "NEWTON COURT BOILER NP (NTCTNP)", gsf: 132, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCTPH", name: "NEWTON COURT PUMPHOUSE 1 (NTCTPH)", gsf: 308, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCTRS", name: "NEWTON COURT BOILER RS (NTCTRS)", gsf: 132, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCTTU", name: "NEWTON COURT BOILER TU (NTCTTU)", gsf: 132, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCTVW", name: "NEWTON COURT BOILER VW (NTCTVW)", gsf: 132, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "NTCTXY", name: "NEWTON COURT BOILER XY (NTCTXY)", gsf: 132, aedCount: 1, lat: 40.0175, lon: -105.2635},
    { code: "OB1", name: "ARTS & SCIENCES OFFICE BUILDING 1 (OB1)", gsf: 8676, aedCount: 3, lat: 40.0118, lon: -105.2735 },
    { code: "OBSR", name: "OBSERVATORY (OBSR)", gsf: 121, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "OBSV", name: "SOMMERS-BAUSCH OBSERVATORY (OBSV)", gsf: 8567, aedCount: 1, lat: 40.0048, lon: -105.2616 },
    { code: "PDLP", name: "PONDEROSA LODGEPOLE (PDLP)", gsf: 2000, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "PDPS", name: "POLICE & PARKING SERVICES CENTER (PDPS)", gsf: 31986, aedCount: 1, lat: 40.0046, lon: -105.2647 },
    { code: "PFDC", name: "PAGE FOUNDATION CENTER (PFDC)", gsf: 10276, aedCount: 1, lat: 40.0105, lon: -105.2774 },
    { code: "PFPS", name: "PRACTICE FOOTBALL FIELD PUMP STATION (PFPS)", gsf: 180, aedCount: 1, lat: 40.0118, lon: -105.2662 },
    { code: "PGRG", name: "PONDEROSA GARAGE (PGRG)", gsf: 343, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "PIKA", name: "PIKA (PIKA)", gsf: 126, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "PORC", name: "PORCUPINE (PORC)", gsf: 127, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "PORT", name: "PORTER BIOSCIENCES (PORT)", gsf: 108808, aedCount: 1, lat: 40.0076, lon: -105.2685 },
    { code: "PPCB", name: "POTTS/PRENTUP CONCESSIONS BUILDING (PPCB)", gsf: 4056, aedCount: 1, lat: 40.0142, lon: -105.2427 },
    { code: "PRL3", name: "4845 PEARL EAST CIRCLE (PRL3)", gsf: 14565, aedCount: 3, lat: 40.0245, lon: -105.2343 },
    { code: "PTRM", name: "PTARMIGAN (PTRM)", gsf: 124, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "RAMY", name: "RAMALEY BIOLOGY BUILDING (RAMY)", gsf: 139442, aedCount: 2, lat: 40.0074, lon: -105.269 },
    { code: "REC", name: "STUDENT RECREATION CENTER (REC)", gsf: 335846, aedCount: 14, lat: 40.0065, lon: -105.268 },
    { code: "REED", name: "REED HALL (REED)", gsf: 25683, aedCount: 1, lat: 40.0041, lon: -105.268 },
    { code: "RES1", name: "RESIDENCE ONE (RES1) (TEMP NAMING)", gsf: 136195, aedCount: 1, lat: 40.013, lon: -105.2718 },
    { code: "RGNT", name: "REGENT ADMINISTRATIVE CENTER (RGNT)", gsf: 89306, aedCount: 1, lat: 40.0035, lon: -105.2655 },
    { code: "RL2", name: "RESEARCH LAB NO 2 (RL2)", gsf: 76855, aedCount: 3, lat: 40.0145, lon: -105.254 },
    { code: "ROBN", name: "ROBIN (ROBN)", gsf: 126, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "RPMP", name: "RESEARCH PARK PUMP STATION (RPMP)", gsf: 295, aedCount: 1, lat: 40.0125, lon: -105.247 },
    { code: "RPRK", name: "REGENT DR AUTOPARK (RPRK)", gsf: 279606, aedCount: 3, lat: 40.0046, lon: -105.2647 },
    { code: "SEEC", name: "SUSTAINABILTY ENERGY AND ENVIRONMENT COMMUNITY (SEEC)", gsf: 292458, aedCount: 2, lat: 40.015, lon: -105.244 },
    { code: "SEEL", name: "SUSTAINABILTY ENERGY AND ENVIRONMENT LABORATORY (SEEL)", gsf: 143721, aedCount: 1, lat: 40.015, lon: -105.244 },
    { code: "SKIS", name: "SKI CENTER STORAGE (SKIS)", gsf: 450, aedCount: 1, lat: 40.0141, lon: -105.2429 },
    { code: "SLHS", name: "SPEECH LANGUAGE AND HEARING SCIENCES (SLHS)", gsf: 22558, aedCount: 1, lat: 40.0048, lon: -105.261 },
    { code: "SLKR", name: "SOCCER LOCKER ROOM (SLKR)", gsf: 2275, aedCount: 1, lat: 40.0141, lon: -105.2431 },
    { code: "SLSH", name: "SPEECH LANGUAGE AND HEARING SCIENCES SHED (SLSH)", gsf: 168, aedCount: 1, lat: 40.0048, lon: -105.261 },
    { code: "SMCTA1", name: "SMILEY COURT A1 (SMCTA1)", gsf: 7740, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTA2", name: "SMILEY COURT A2 (SMCTA2)", gsf: 11563, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTA3", name: "SMILEY COURT A3 (SMCTA3)", gsf: 11563, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTB1", name: "SMILEY COURT B1 (SMCTB1)", gsf: 18305, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTB2", name: "SMILEY COURT B2 (SMCTB2)", gsf: 18302, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTB3", name: "SMILEY COURT B3 (SMCTB3)", gsf: 18300, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTB4", name: "SMILEY COURT B4 (SMCTB4)", gsf: 18300, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTD1", name: "SMILEY COURT D1 (SMCTD1)", gsf: 3966, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTD10", name: "SMILEY COURT D10 (SMCTD10)", gsf: 5928, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTD2", name: "SMILEY COURT D2 (SMCTD2)", gsf: 5928, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTD3", name: "SMILEY COURT D3 (SMCTD3)", gsf: 3966, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTD4", name: "SMILEY COURT D4 (SMCTD4)", gsf: 5928, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTD5", name: "SMILEY COURT D5 (SMCTD5)", gsf: 5928, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTD6", name: "SMILEY COURT D6 (SMCTD6)", gsf: 3966, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTD7", name: "SMILEY COURT D7 (SMCTD7)", gsf: 3966, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTD8", name: "SMILEY COURT D8 (SMCTD8)", gsf: 3966, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTD9", name: "SMILEY COURT D9 (SMCTD9)", gsf: 7892, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTE1", name: "SMILEY COURT E1 (SMCTE1)", gsf: 10873, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTE2", name: "SMILEY COURT E2 (SMCTE2)", gsf: 10873, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTE3", name: "SMILEY COURT E3 (SMCTE3)", gsf: 10873, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTE4", name: "SMILEY COURT E4 (SMCTE4)", gsf: 10873, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTL1", name: "SMILEY COURT L1 (SMCTL1)", gsf: 346, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTL2", name: "SMILEY COURT L2 (SMCTL2)", gsf: 676, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTL3", name: "SMILEY COURT L3 (SMCTL3)", gsf: 346, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTM1", name: "SMILEY COURT MAIL 1 (SMCTM1)", gsf: 170, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTM2", name: "SMILEY COURT MAIL 2 (SMCTM2)", gsf: 170, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTM3", name: "SMILEY COURT MAIL 3 (SMCTM3)", gsf: 170, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTS1", name: "SMILEY COURT STORAGE 1 (SMCTS1)", gsf: 170, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTS2", name: "SMILEY COURT STORAGE 2 (SMCTS2)", gsf: 170, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTS3", name: "SMILEY COURT STORAGE 3 (SMCTS3)", gsf: 170, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTS4", name: "SMILEY COURT STORAGE 4 (SMCTS4)", gsf: 170, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMCTS5", name: "SMILEY COURT STORAGE 5 (SMCTS5)", gsf: 170, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "SMTH", name: "SMITH HALL (SMTH)", gsf: 96667, aedCount: 1, lat: 40.005, lon: -105.2608 },
    { code: "SPRG", name: "SPRING HOUSE (SPRG)", gsf: 100, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "SPSC", name: "SPACE SCIENCE BUILDING (SPSC)", gsf: 100039, aedCount: 2, lat: 40.0138, lon: -105.2435 },
    { code: "SPSK", name: "SAPSUCKER (SPSK)", gsf: 120, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "SSKN", name: "SISKEN (SSKN)", gsf: 115, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "ST74", name: "STORAGE BUILDING 74 (ST74)", gsf: 0, aedCount: 1, lat: 39.9765, lon: -105.254 },
    { code: "STAD", name: "STADIUM BUILDING (STAD)", gsf: 151963, aedCount: 1, lat: 40.009, lon: -105.2665 },
    { code: "STNC", name: "STEARNS TOWERS CENTER (STNC)", gsf: 22523, aedCount: 1, lat: 40.001, lon: -105.257 },
    { code: "STNE", name: "STEARNS TOWERS EAST (STNE)", gsf: 113703, aedCount: 1, lat: 40.001, lon: -105.257 },
    { code: "STNW", name: "STEARNS TOWERS WEST (STNW)", gsf: 113459, aedCount: 1, lat: 40.001, lon: -105.257 },
    { code: "STSB", name: "STADIUM SKY BOX (STSB)", gsf: 114504, aedCount: 3, lat: 40.009, lon: -105.2665 },
    { code: "STTB", name: "STADIUM TICKET BUILDING (STTB)", gsf: 554, aedCount: 1, lat: 40.009, lon: -105.266 },
    { code: "SUMM", name: "SUMMER (SUMM)", gsf: 347, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "SWLL", name: "SEWALL HALL (SWLL)", gsf: 99242, aedCount: 2, lat: 40.007, lon: -105.271 },
    { code: "TB01", name: "ALBERT AND VERA RAMIREZ TEMPORARY BUILDING 1 (TB01)", gsf: 8673, aedCount: 3, lat: 40.0071, lon: -105.2704 },
    { code: "TB15", name: "ELECTRIC SUPPLY BUILDING (TB15)", gsf: 1309, aedCount: 1, lat: 40.0131, lon: -105.253 },
    { code: "TB16", name: "TELECOM EQUIPMENT BUILDING SMILEY COURT (TB16)", gsf: 131, aedCount: 1, lat: 40.0135, lon: -105.252 },
    { code: "TB19", name: "UNIVERSITY ADMINISTRATIVE CENTER ANNEX (TB19)", gsf: 2199, aedCount: 1, lat: 40.009, lon: -105.2818 },
    { code: "TB33", name: "FAMILY HOUSING EXPANSION (133) (TB33)", gsf: 4326, aedCount: 1, lat: 40.0125, lon: -105.2745 },
    { code: "TB45", name: "WAREHOUSE NO 1 (TB45)", gsf: 2000, aedCount: 1, lat: 40.0129, lon: -105.2519 },
    { code: "TB46", name: "WAREHOUSE NO 2 (TB46)", gsf: 2000, aedCount: 1, lat: 40.0129, lon: -105.2519 },
    { code: "TB47", name: "WAREHOUSE NO 3 (TB47)", gsf: 2000, aedCount: 1, lat: 40.0129, lon: -105.2519 },
    { code: "TB48", name: "WAREHOUSE NO 4 (TB48)", gsf: 2000, aedCount: 1, lat: 40.0129, lon: -105.2519 },
    { code: "TB49", name: "STEAM CONVERSION SHED (TB49)", gsf: 1688, aedCount: 1, lat: 40.0127, lon: -105.2718 },
    { code: "TB55", name: "PRACTICE FOOTBALL FIELD BUILDING (TB55)", gsf: 289, aedCount: 1, lat: 40.0118, lon: -105.2662 },
    { code: "TB65", name: "TEMPORARY BUILDING 65 (TB65)", gsf: 2923, aedCount: 1, lat: 40.0112, lon: -105.2779 },
    { code: "TB65A", name: "TEMPORARY BUILDING 65 GARAGE (TB65A)", gsf: 390, aedCount: 1, lat: 40.0112, lon: -105.2779 },
    { code: "TB66", name: "TEMPORARY BUILDING 66 (TB66)", gsf: 3823, aedCount: 1, lat: 40.0105, lon: -105.2755 },
    { code: "TB70", name: "TEMPORARY BUILDING 70 (TB70)", gsf: 3793, aedCount: 1, lat: 40.011, lon: -105.2773 },
    { code: "TB72", name: "TEMPORARY BUILDING 72 (TB72)", gsf: 16576, aedCount: 1, lat: 39.9765, lon: -105.254 },
    { code: "TB78", name: "TEMPORARY BUILDING 78 (TB78)", gsf: 1674, aedCount: 1, lat: 40.0104, lon: -105.2783 },
    { code: "TB82", name: "TEMPORARY BUILDING 82 (TB82)", gsf: 4436, aedCount: 1, lat: 40.0114, lon: -105.2772 },
    { code: "TB83", name: "POTTS FIELD TRACK STORAGE (TB83)", gsf: 1285, aedCount: 1, lat: 40.0142, lon: -105.2427 },
    { code: "TB84", name: "BRYAN BENJAMIN SAX SKI TEAM BUILDNG (TB84)", gsf: 3517, aedCount: 1, lat: 40.0142, lon: -105.2427 },
    { code: "TB85", name: "AUXILARY TRACK STORAGE NORTHWEST OF POTTS FIELD (TB85)", gsf: 720, aedCount: 1, lat: 40.0142, lon: -105.2427 },
    { code: "TB88", name: "TEMPORARY BUILDING 88 (TB88)", gsf: 3193, aedCount: 1, lat: 40.0112, lon: -105.2768 },
    { code: "TB90", name: "TEMPORARY BUILDING 90 (TB90)", gsf: 2092, aedCount: 1, lat: 40.0103, lon: -105.2782 },
    { code: "TB93", name: "TEMPORARY BUILDING 93 (TB93)", gsf: 3082, aedCount: 1, lat: 40.0113, lon: -105.277 },
    { code: "TB99", name: "TEMPORARY BUILDING 99 (TB99)", gsf: 1394, aedCount: 1, lat: 40.0106, lon: -105.2757 },
    { code: "TETN", name: "TETON (TETN)", gsf: 126, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "THTR", name: "UNIVERSITY THEATRE (THTR)", gsf: 71239, aedCount: 1, lat: 40.0083, lon: -105.274 },
    { code: "TLRS", name: "TULAROOSA (TLRS)", gsf: 126, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "TNDR", name: "TUNDRA LAB (TNDR)", gsf: 1232, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "TRAN", name: "TRANSPORTATION CENTER AND ANNEX (TRAN)", gsf: 9349, aedCount: 1, lat: 40.0125, lon: -105.253 },
    { code: "UCTR", name: "UNIVERSITY ADMINISTRATIVE CENTER (UCTR)", gsf: 15174, aedCount: 1, lat: 40.009, lon: -105.2818 },
    { code: "UINT", name: "UINTA (UINT)", gsf: 126, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "UMC", name: "UNIVERSITY MEMORIAL CENTER (UMC)", gsf: 257485, aedCount: 3, lat: 40.007, lon: -105.2725 },
    { code: "URES", name: "UNIVERSITY RESIDENCE (URES)", gsf: 11054, aedCount: 1, lat: 39.9999, lon: -105.249 },
    { code: "VAC", name: "VISUAL ARTS COMPLEX (VAC)", gsf: 179813, aedCount: 1, lat: 40.0067, lon: -105.2733 },
    { code: "VHCL", name: "VEHICLE STORAGE (VHCL)", gsf: 913, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "VPMP", name: "VARSITY LAKE PUMP STATION (VPMP)", gsf: 401, aedCount: 1, lat: 40.0084, lon: -105.2764 },
    { code: "WALN", name: "WALNUT DISTRIBUTION CENTER (WALN)", gsf: 146582, aedCount: 2, lat: 40.021, lon: -105.252 },
    { code: "WARD", name: "WARDENBURG STUDENT HEALTH CENTER (WARD)", gsf: 55963, aedCount: 3, lat: 40.006, lon: -105.267 },
    { code: "WASA", name: "WASATCH (WASA)", gsf: 126, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "WDBY", name: "WOODBURY ARTS & SCIENCES BUILDING (WDBY)", gsf: 12937, aedCount: 1, lat: 40.0075, lon: -105.274 },
    { code: "WDEP", name: "WEST DISTRICT ENERGY PLANT (WDEP)", gsf: 22647, aedCount: 1, lat: 40.008, lon: -105.279 },
    { code: "WDIL", name: "1164 W DILLON RD (WDIL)", gsf: 58609, aedCount: 3, lat: 39.9805, lon: -105.1477 },
    { code: "WEB", name: "WEBER HALL (WEB)", gsf: 190867, aedCount: 3, lat: 39.9987, lon: -105.255 },
    { code: "WILD", name: "2860 WILDERNESS PLACE (WILD)", gsf: 63191, aedCount: 1, lat: 40.0242, lon: -105.244 },
    { code: "WIND", name: "WIND TUNNEL (WIND)", gsf: 3469, aedCount: 1, lat: 40.015, lon: -105.244 },
    { code: "WLAW", name: "WOLF LAW BUILDING (WLAW)", gsf: 190007, aedCount: 1, lat: 40.005, lon: -105.2619 },
    { code: "WLLW", name: "WILLOW (WLLW)", gsf: 336, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "WLRD", name: "WILLARD HALL (WLRD)", gsf: 100969, aedCount: 1, lat: 40.004, lon: -105.265 },
    { code: "WMGBA", name: "WEST MAIN GROUNDS BUILDING A (WMGBA)", gsf: 110, aedCount: 1, lat: 40.0118, lon: -105.2735 },
    { code: "WMGBB", name: "WEST MAIN GROUNDS BUILDING B (WMGBB)", gsf: 110, aedCount: 1, lat: 40.0118, lon: -105.2735 },
    { code: "WMGBC", name: "WEST MAIN GROUNDS BUILDING C (WMGBC)", gsf: 297, aedCount: 1, lat: 40.0118, lon: -105.2735 },
    { code: "WMGBD", name: "WEST MAIN GROUNDS BUILDING D (WMGBD)", gsf: 99, aedCount: 1, lat: 40.0118, lon: -105.2735 },
    { code: "WPTI", name: "WAPATI (WPTI)", gsf: 126, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "WRVR", name: "WIND RIVER (WRVR)", gsf: 126, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "WSTE", name: "WASTE TREATMENT (WSTE)", gsf: 619, aedCount: 1, lat: 39.9926, lon: -105.5457 },
    { code: "WVC", name: "WILLIAMS VILLAGE DINING AND COMMUNITY COMMONS (WVC)", gsf: 114873, aedCount: 1, lat: 40.0013, lon: -105.257 },
    { code: "WVE", name: "WILLIAMS VILLAGE EAST (WVE)", gsf: 188831, aedCount: 1, lat: 39.998, lon: -105.253 },
    { code: "WVHP", name: "WILLIAMS VILLAGE HEATING PLANT (WVHP)", gsf: 8277, aedCount: 1, lat: 39.999, lon: -105.255 },
    { code: "WVN", name: "WILLIAMS VILLAGE NORTH (WVN)", gsf: 145874, aedCount: 1, lat: 40.0003, lon: -105.254 },
    { code: "WVPH", name: "WILLIAMS VILLAGE PUMPHOUSE (WVPH)", gsf: 456, aedCount: 1, lat: 40.0003, lon: -105.252 },
    { code: "WVRC", name: "WILLIAMS VILLAGE RECREATION CENTER (WVRC)", gsf: 11038, aedCount: 1, lat: 39.999, lon: -105.2555 },
    { code: "WVSTO", name: "WILLIAMS VILLAGE GROUNDS STORAGE (WVSTO)", gsf: 896, aedCount: 1, lat: 39.9995, lon: -105.2558 },
    { code: "XDCB", name: "XD CABIN (XDCB)", gsf: 831, aedCount: 3, lat: 40.011, lon: -105.277 },
    { code: "ZUNI", name: "ZUNI (ZUNI)", gsf: 126, aedCount: 1, lat: 39.9926, lon: -105.5457 }
];

// Global variables accessible to all functions
let currentClusters = [];

document.addEventListener('DOMContentLoaded', () => {
    const summaryContentEl = document.getElementById('summary-content');
    const loaderEl = document.getElementById('loader');
    const mapElement = document.getElementById('map');
    const recalcButton = document.getElementById('recalculate-btn');

    // --- CONFIGURATION ---
    let TIME_PER_AED = 5; // 5 minutes per AED as requested
    let TIME_PER_50K_GSF = 1;
    let AED_LOCATION_BUFFER = 8; // 8 minutes per building/wing to locate AEDs (first-time search)
    let WALKING_SPEED_MPH = 3.1;
    let DRIVING_SPEED_MPH = 25; // Campus/city driving speed
    let PARKING_TIME = 3; // Additional time for parking and walking from car
    let WALKING_THRESHOLD = 20; // Switch to driving if walking > 20 minutes
    let METERS_PER_MINUTE_WALKING = (WALKING_SPEED_MPH * 1609.34) / 60;
    let METERS_PER_MINUTE_DRIVING = (DRIVING_SPEED_MPH * 1609.34) / 60;
    let MAX_CLUSTER_TIME = 240;
    let AVAILABLE_WORKERS = 10; // Number of student workers available
    const BASE_COLORS = [
        '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b',
        '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#aec7e8', '#ffbb78',
        '#98df8a', '#ff9896', '#c5b0d5', '#c49c94', '#f7b6d2', '#c7c7c7',
        '#dbdb8d', '#9edae5'
    ];
    
    // Building addresses (for PDF report)
    const buildingAddresses = {
        "1135BRD": "1135 Broadway, Boulder, CO 80302",
        "122126TH": "1221 26th Street, Boulder, CO 80302",
        "1301WA": "1301 Walnut Street, Boulder, CO 80302", 
        "1506BRD": "1506 Broadway, Boulder, CO 80302",
        "1522BRD": "1522 Broadway, Boulder, CO 80302",
        "MAIN": "914 Broadway, Boulder, CO 80309",
        "LIBR": "1720 Pleasant St, Boulder, CO 80309",
        "UMC": "1669 Euclid Ave, Boulder, CO 80309",
        "KOBL": "995 Regent Dr, Boulder, CO 80309",
        "EVNT": "1981 Regent Dr, Boulder, CO 80309",
        "REC": "2050 Regent Dr, Boulder, CO 80309",
        "CHMP": "3300 Colorado Ave, Boulder, CO 80303",
        // Add more addresses as needed - defaulting to campus for unknown addresses
    };

    function getBuildingAddress(code, name) {
        return buildingAddresses[code] || `University of Colorado Boulder Campus, Boulder, CO 80309 (${name})`;
    }

    // --- LEAFLET MAP & LAYER GROUP SETUP ---
    const map = L.map(mapElement).setView([40.0076, -105.2659], 14);
    
    // Add multiple base layers for better building identification
    const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        maxZoom: 19,
    });
    
    const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
        maxZoom: 19,
    });
    
    const hybridLayer = L.layerGroup([
        satelliteLayer,
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
            attribution: '',
            maxZoom: 19,
        })
    ]);
    
    // Start with street map view (user preference)
    osmLayer.addTo(map);
    
    // Add layer control
    const baseLayers = {
        "Satellite": satelliteLayer,
        "Hybrid": hybridLayer,
        "Street Map": osmLayer
    };
    L.control.layers(baseLayers).addTo(map);
    
    L.control.scale({imperial: false}).addTo(map);
    const mapLayers = L.featureGroup().addTo(map);
    
    // Initialize add building modal now that map is ready
    initializeAddBuildingModal();
    
    // Variables to store cluster-related information
    let manuallyArranged = false;
    let routeSegments = []; // Store references to route segments for replacement
    let actualRouteTimes = {}; // Store actual route times for sidebar updates
    
    // Rectangle selection variables
    let isSelecting = false;
    let selectionStartPoint = null;
    let selectionRectangle = null;
    let selectedMarkers = new Set();
    let isDraggingGroup = false;
    
    // Cluster visibility tracking
    let clusterVisibility = {}; // Track which clusters are visible

    // --- GEOCODING FUNCTION ---
    async function geocodeBuilding(buildingName, code) {
        try {
            // Use Nominatim (OpenStreetMap) geocoding service
            const query = encodeURIComponent(`${buildingName} University of Colorado Boulder`);
            const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${query}&limit=1&countrycodes=us`);
            const data = await response.json();
            
            if (data && data.length > 0) {
                const lat = parseFloat(data[0].lat);
                const lon = parseFloat(data[0].lon);
                
                // Only use if it's within reasonable bounds of CU Boulder campus
                if (lat >= 39.99 && lat <= 40.02 && lon >= -105.30 && lon <= -105.24) {
                    console.log(`Geocoded ${code}: ${lat}, ${lon}`);
                    return { lat, lon };
                }
            }
        } catch (error) {
            console.log(`Geocoding failed for ${code}:`, error);
        }
        return null;
    }

    // --- IMPROVED GEOCODING BUTTON ---
    function addGeocodeButton() {
        const geocodeContainer = document.createElement('div');
        geocodeContainer.style.cssText = 'margin-bottom: 10px;';
        
        const geocodeBtn = document.createElement('button');
        geocodeBtn.id = 'geocode-btn';
        geocodeBtn.textContent = 'Re-geocode All from Addresses';
        geocodeBtn.style.cssText = `
            display: block; width: 100%; padding: 8px; font-size: 0.9em; font-weight: bold;
            background-color: #e74c3c; color: white; border: none; border-radius: 5px;
            cursor: pointer; margin-bottom: 8px; transition: background-color 0.2s;
        `;
        geocodeBtn.addEventListener('mouseover', () => {
            if (!geocodeBtn.disabled) geocodeBtn.style.backgroundColor = '#c0392b';
        });
        geocodeBtn.addEventListener('mouseout', () => {
            if (!geocodeBtn.disabled) geocodeBtn.style.backgroundColor = '#e74c3c';
        });
        
        // Progress container (initially hidden)
        const progressContainer = document.createElement('div');
        progressContainer.id = 'geocode-progress';
        progressContainer.style.cssText = 'display: none; margin-top: 8px;';
        progressContainer.innerHTML = `
            <div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 8px; font-size: 0.85em;">
                <div style="margin-bottom: 4px;">
                    <span id="progress-text" style="color: #495057; font-weight: 500;">Initializing...</span>
                </div>
                <div style="background: #e9ecef; border-radius: 10px; height: 8px; overflow: hidden;">
                    <div id="progress-bar" style="background: #28a745; height: 100%; width: 0%; transition: width 0.3s ease; border-radius: 10px;"></div>
                </div>
                <div style="margin-top: 4px; font-size: 0.75em; color: #6c757d;">
                    <span id="progress-stats">0 of ${buildingData.length} buildings processed</span>
                </div>
            </div>
        `;
        
        geocodeBtn.addEventListener('click', async () => {
            geocodeBtn.textContent = 'Re-geocoding from addresses...';
            geocodeBtn.disabled = true;
            geocodeBtn.style.backgroundColor = '#6c757d';
            geocodeBtn.style.cursor = 'not-allowed';
            
            // Show progress container
            progressContainer.style.display = 'block';
            
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            const progressStats = document.getElementById('progress-stats');
            
            let improved = 0;
            let processed = 0;
            const total = buildingData.length;
            
            for (let i = 0; i < buildingData.length; i++) {
                const building = buildingData[i];
                processed = i + 1;
                
                // Get the address for this building
                const buildingAddress = getBuildingAddress(building.code, building.name);
                
                // Update progress text
                progressText.textContent = `Geocoding ${building.code} from: ${buildingAddress.substring(0, 50)}${buildingAddress.length > 50 ? '...' : ''}`;
                
                // Update progress bar
                const percentage = (processed / total) * 100;
                progressBar.style.width = `${percentage}%`;
                
                // Update stats
                progressStats.textContent = `${processed} of ${total} buildings processed ‚Ä¢ ${improved} improved`;
                
                // Attempt geocoding using the building's address
                try {
                    // Store the original address to preserve it
                    const originalAddress = buildingAddresses[building.code] || buildingAddress;
                    
                    // Geocode using the address (suppress alerts for batch processing)
                    const result = await geocodeAddress(buildingAddress, true);
                    if (result) {
                        // Auto-accept the new coordinates
                        building.lat = result.lat;
                        building.lon = result.lon;
                        // Keep the original address string unchanged
                        buildingAddresses[building.code] = originalAddress;
                        improved++;
                        
                        console.log(`‚úÖ Re-geocoded ${building.code} to ${result.lat}, ${result.lon} using address: ${buildingAddress}`);
                        
                        // Update improved count in real-time
                        progressStats.textContent = `${processed} of ${total} buildings processed ‚Ä¢ ${improved} improved`;
                        
                        // Brief green flash for successful geocoding
                        progressBar.style.background = '#28a745';
                    } else {
                        console.log(`‚ùå Could not geocode ${building.code} from address: ${buildingAddress}`);
                        // Brief yellow flash for no result
                        progressBar.style.background = '#ffc107';
                        setTimeout(() => progressBar.style.background = '#28a745', 200);
                    }
                } catch (error) {
                    console.error(`Geocoding error for ${building.code}:`, error);
                    // Brief red flash for error
                    progressBar.style.background = '#dc3545';
                    setTimeout(() => progressBar.style.background = '#28a745', 200);
                }
                
                // Respectful delay for geocoding service
                await new Promise(resolve => setTimeout(resolve, 800));
            }
            
            // Final completion state
            progressText.textContent = `Completed! ${improved} building locations updated from addresses.`;
            progressStats.textContent = `${total} of ${total} buildings processed ‚Ä¢ ${improved} improved`;
            progressBar.style.width = '100%';
            progressBar.style.background = '#28a745';
            
            // Update button
            geocodeBtn.textContent = `Updated ${improved} locations`;
            geocodeBtn.style.backgroundColor = '#28a745';
            
            // Hide progress after delay and reset button
            setTimeout(() => {
                progressContainer.style.display = 'none';
                geocodeBtn.textContent = 'Re-geocode All from Addresses';
                geocodeBtn.disabled = false;
                geocodeBtn.style.backgroundColor = '#e74c3c';
                geocodeBtn.style.cursor = 'pointer';
                
                // Reset progress for next time
                progressBar.style.width = '0%';
                progressText.textContent = 'Initializing...';
                progressStats.textContent = `0 of ${buildingData.length} buildings processed`;
            }, 3000);
            
            // Refresh the display
            processAndDisplayData();
        });
        
        // Add auto-geocode button for missing locations
        const autoGeocodeBtn = document.createElement('button');
        autoGeocodeBtn.id = 'auto-geocode-btn';
        autoGeocodeBtn.textContent = 'üîç Auto-Geocode Missing Locations';
        autoGeocodeBtn.style.cssText = `
            display: block; width: 100%; padding: 8px; font-size: 0.9em; font-weight: bold;
            background-color: #2e7d32; color: white; border: none; border-radius: 5px;
            cursor: pointer; margin-bottom: 8px; transition: background-color 0.2s;
        `;
        autoGeocodeBtn.addEventListener('mouseover', () => {
            if (!autoGeocodeBtn.disabled) autoGeocodeBtn.style.backgroundColor = '#1b5e20';
        });
        autoGeocodeBtn.addEventListener('mouseout', () => {
            if (!autoGeocodeBtn.disabled) autoGeocodeBtn.style.backgroundColor = '#2e7d32';
        });
        
        autoGeocodeBtn.addEventListener('click', async () => {
            const buildingsNeedingGeocode = buildingData.filter(b => 
                !buildingAddresses[b.code] || buildingAddresses[b.code].trim() === ''
            );
            
            if (buildingsNeedingGeocode.length === 0) {
                alert('All buildings already have addresses! Use the "Re-geocode All from Addresses" button to re-geocode existing addresses.');
                return;
            }
            
            const proceed = confirm(`Found ${buildingsNeedingGeocode.length} buildings without addresses. Would you like to automatically geocode them using their building names?\n\nThis will:\n‚Ä¢ Search for each building by name\n‚Ä¢ Set coordinates if found\n‚Ä¢ Update addresses with results\n\nThis may take a few minutes.`);
            
            if (!proceed) return;
            
            autoGeocodeBtn.textContent = 'üîÑ Auto-Geocoding...';
            autoGeocodeBtn.disabled = true;
            autoGeocodeBtn.style.backgroundColor = '#6c757d';
            autoGeocodeBtn.style.cursor = 'not-allowed';
            
            let processed = 0;
            let improved = 0;
            
            for (const building of buildingsNeedingGeocode) {
                processed++;
                autoGeocodeBtn.textContent = `üîÑ Geocoding ${processed}/${buildingsNeedingGeocode.length}`;
                
                try {
                    // Try geocoding with building name + "Boulder CO" for better results
                    const searchTerm = `${building.name}, Boulder, CO`;
                    const result = await geocodeAddress(searchTerm);
                    
                    if (result) {
                        building.lat = result.lat;
                        building.lon = result.lon;
                        buildingAddresses[building.code] = result.display_name || searchTerm;
                        improved++;
                        console.log(`‚úÖ Geocoded ${building.code}: ${result.lat}, ${result.lon}`);
                    } else {
                        console.log(`‚ùå Could not geocode ${building.code}: ${building.name}`);
                    }
                } catch (error) {
                    console.error(`Error geocoding ${building.code}:`, error);
                }
                
                // Respectful delay for geocoding service
                await new Promise(resolve => setTimeout(resolve, 800));
            }
            
            autoGeocodeBtn.textContent = `‚úÖ Geocoded ${improved} buildings`;
            autoGeocodeBtn.style.backgroundColor = '#28a745';
            
            // Reset button after delay
            setTimeout(() => {
                autoGeocodeBtn.textContent = 'üîç Auto-Geocode Missing Locations';
                autoGeocodeBtn.disabled = false;
                autoGeocodeBtn.style.backgroundColor = '#2e7d32';
                autoGeocodeBtn.style.cursor = 'pointer';
            }, 3000);
            
            if (improved > 0) {
                alert(`‚úÖ Successfully geocoded ${improved} out of ${buildingsNeedingGeocode.length} buildings!\n\nThe map will now refresh with updated locations.`);
                processAndDisplayData();
            } else {
                alert('‚ùå Could not geocode any buildings. You may need to add addresses manually using the Edit button for each building.');
            }
        });
        
        geocodeContainer.appendChild(geocodeBtn);
        geocodeContainer.appendChild(autoGeocodeBtn);
        geocodeContainer.appendChild(progressContainer);
        document.querySelector('.button-controls').appendChild(geocodeContainer);
    }

    // --- ADD ZOOM TO CAMPUS BUTTON ---
    function addZoomButton() {
        const zoomBtn = document.createElement('button');
        zoomBtn.textContent = 'Zoom to CU Boulder Campus';
        zoomBtn.style.cssText = `
            display: block; width: 100%; padding: 8px; font-size: 0.9em; font-weight: bold;
            background-color: #27ae60; color: white; border: none; border-radius: 5px;
            cursor: pointer; margin-bottom: 10px; transition: background-color 0.2s;
        `;
        zoomBtn.addEventListener('mouseover', () => zoomBtn.style.backgroundColor = '#229954');
        zoomBtn.addEventListener('mouseout', () => zoomBtn.style.backgroundColor = '#27ae60');
        
        zoomBtn.addEventListener('click', () => {
            map.setView([40.0076, -105.2659], 15);
        });
        
        document.querySelector('.button-controls').appendChild(zoomBtn);
    }

    // --- PDF REPORT GENERATION ---
    async function generatePDFReport(clusters) {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('p', 'mm', 'letter'); // US Letter size
        
        // Define 0.75" margins (19.05mm)
        const MARGIN = 19.05; // 0.75 inches in mm
        const PAGE_WIDTH = 215.9; // US Letter width in mm
        const PAGE_HEIGHT = 279.4; // US Letter height in mm
        const CONTENT_WIDTH = PAGE_WIDTH - (2 * MARGIN); // Available content width
        const CONTENT_HEIGHT = PAGE_HEIGHT - (2 * MARGIN); // Available content height
        
        let yPosition = MARGIN;
        
        // Title Page
        pdf.setFontSize(20);
        pdf.setTextColor(40);
        pdf.text('CU Boulder AED Inventory Work Plan', MARGIN, yPosition);
        yPosition += 15;
        
        pdf.setFontSize(12);
        pdf.text('Generated: ' + new Date().toLocaleDateString(), MARGIN, yPosition);
        yPosition += 10;
        pdf.text('Prepared for: CU Boulder Division of Public Safety', MARGIN, yPosition);
        yPosition += 8;
        pdf.text('Total Work Blocks: ' + clusters.length, MARGIN, yPosition);
        yPosition += 15;
        
        // Labor Hour Summary
        const totalTime = clusters.reduce((sum, cluster) => sum + cluster.totalTime, 0);
        const totalHours = totalTime / 60;
        const totalAEDs = clusters.reduce((sum, cluster) => {
            return sum + cluster.path.reduce((aedSum, building) => aedSum + building.aedCount, 0);
        }, 0);
        const totalBuildings = clusters.reduce((sum, cluster) => sum + cluster.path.length, 0);
        
        pdf.setFontSize(14);
        pdf.setTextColor(180, 0, 0); // Red for emphasis
        pdf.text('PROJECT LABOR ESTIMATE', MARGIN, yPosition);
        yPosition += 12;
        
        pdf.setFontSize(12);
        pdf.setTextColor(40);
        pdf.text(`Total Estimated Labor: ${totalHours.toFixed(1)} hours`, MARGIN, yPosition);
        yPosition += 8;
        pdf.text(`Total Buildings: ${totalBuildings}`, MARGIN, yPosition);
        yPosition += 8;
        pdf.text(`Total AEDs to Inventory: ${totalAEDs} (assumed)`, MARGIN, yPosition);
        yPosition += 8;
        pdf.text(`Average Time per Building: ${(totalTime/totalBuildings).toFixed(1)} minutes`, MARGIN, yPosition);
        yPosition += 8;
        pdf.text(`Average Time per AED: ${TIME_PER_AED} minutes`, MARGIN, yPosition);
        yPosition += 15;
        
        pdf.setFontSize(14);
        pdf.text('Instructions for Student Worker:', MARGIN, yPosition);
        yPosition += 10;
        
        pdf.setFontSize(10);
        const instructions = [
            '1. Each AED check should take approximately 5 minutes',
            '2. Follow the building order shown in each work block',
            '3. Record any issues or missing AEDs immediately',
            '4. Take photos of AED locations for verification',
            '5. Contact supervisor if any building is inaccessible',
            '6. Walking times are estimates - allow extra time for navigation'
        ];
        
        instructions.forEach(instruction => {
            pdf.text(instruction, MARGIN + 5, yPosition);
            yPosition += 6;
        });
        
        // Summary table
        yPosition += 10;
        pdf.setFontSize(12);
        pdf.text('Work Block Summary:', MARGIN, yPosition);
        yPosition += 10;
        
        clusters.forEach((cluster, index) => {
            const totalAEDs = cluster.path.reduce((sum, building) => sum + building.aedCount, 0);
            pdf.setFontSize(10);
            pdf.text(`Block ${index + 1}: ${cluster.path.length} buildings, ${totalAEDs} AEDs, ~${Math.round(cluster.totalTime)} minutes (${(cluster.totalTime/60).toFixed(1)} hours)`, MARGIN + 5, yPosition);
            yPosition += 6;
        });

        // Add methodology page
        pdf.addPage();
        yPosition = MARGIN;
        
        pdf.setFontSize(16);
        pdf.setTextColor(40);
        pdf.text('METHODOLOGY & ASSUMPTIONS', MARGIN, yPosition);
        yPosition += 15;
        
        pdf.setFontSize(12);
        pdf.text('Time Calculation Logic:', MARGIN, yPosition);
        yPosition += 10;
        
        pdf.setFontSize(10);
        const methodology = [
            'BASE ASSUMPTIONS:',
            `‚Ä¢ AED Location Buffer: Variable per building (default ${AED_LOCATION_BUFFER} minutes)`,
            '  - Time to search each building section and locate all AEDs',
            '  - Customizable per building based on complexity and size',
            '  - Accounts for buildings with multiple wings/sections',
            '  - First-time inventory requires thorough exploration',
            '  - Includes checking common AED locations (lobbies, hallways, etc.)',
            '',
            `‚Ä¢ AED Inspection Time: ${TIME_PER_AED} minutes per device`,
            '  - Includes visual inspection and documentation',
            '  - Based on standard safety inspection protocols',
            '  - Applied after AEDs are located',
            '',
            '‚Ä¢ Building Navigation Time: Variable by building size',
            `  - Large buildings (>50,000 GSF): +${TIME_PER_50K_GSF} minute per 50k sq ft`,
            '  - Accounts for finding AEDs within complex buildings',
            '  - Includes elevator wait times and navigation',
            '',
            '‚Ä¢ Inter-Building Travel Time:',
            `  - Walking speed: ${WALKING_SPEED_MPH} mph (${(METERS_PER_MINUTE_WALKING).toFixed(0)} meters/minute)`,
            `  - Driving speed: ${DRIVING_SPEED_MPH} mph (${(METERS_PER_MINUTE_DRIVING).toFixed(0)} meters/minute)`,
            `  - Automatically switches to driving for trips > ${WALKING_THRESHOLD} minutes walking`,
            `  - Driving time includes ${PARKING_TIME} minutes for parking and walking to building`,
            '  - Calculated using GPS coordinates and straight-line distance',
            '  - Includes time for building entry/exit',
            '',
            'CLUSTERING ALGORITHM:',
            `‚Ä¢ Maximum cluster time: ${MAX_CLUSTER_TIME} minutes (${MAX_CLUSTER_TIME/60} hours)`,
            '‚Ä¢ Geographic proximity prioritized to minimize travel',
            '‚Ä¢ Logical building sequences to optimize efficiency',
            '',
            'LABOR CALCULATIONS:',
            '‚Ä¢ Each work block assigned to one individual',
            '‚Ä¢ Times include all necessary activities:',
            '  - Travel between buildings',
            '  - Building access and navigation', 
            '  - AED location and inspection',
            '  - Documentation and reporting',
            '',
            'CONTINGENCY CONSIDERATIONS:',
            '‚Ä¢ Add 10-15% buffer for unforeseen delays',
            '‚Ä¢ Some buildings may require special access',
            '‚Ä¢ Weather conditions may affect travel times',
            '‚Ä¢ Student worker may need occasional guidance'
        ];
        
        methodology.forEach(line => {
            if (line === '') {
                yPosition += 4;
            } else if (line.endsWith(':')) {
                pdf.setTextColor(40);
                pdf.setFontSize(11);
                pdf.text(line, MARGIN, yPosition);
                yPosition += 8;
            } else if (line.startsWith('‚Ä¢')) {
                pdf.setTextColor(60);
                pdf.setFontSize(9);
                pdf.text(line, MARGIN + 5, yPosition);
                yPosition += 6;
            } else if (line.startsWith('  -')) {
                pdf.setTextColor(100);
                pdf.setFontSize(8);
                pdf.text(line, MARGIN + 10, yPosition);
                yPosition += 5;
            } else {
                pdf.setTextColor(40);
                pdf.setFontSize(10);
                pdf.text(line, MARGIN, yPosition);
                yPosition += 7;
            }
            
            // Check if we need a new page
            if (yPosition > (PAGE_HEIGHT - MARGIN - 20)) {
                pdf.addPage();
                yPosition = MARGIN;
            }
        });
        
        // Cost implications section
        yPosition += 10;
        pdf.setFontSize(12);
        pdf.setTextColor(180, 0, 0);
        pdf.text('STAFFING RECOMMENDATIONS:', MARGIN, yPosition);
        yPosition += 10;
        
        pdf.setFontSize(10);
        pdf.setTextColor(40);
        
        // Calculate staffing logistics
        const workBlocksPerWorker = Math.ceil(clusters.length / AVAILABLE_WORKERS);
        const maxTimePerWorker = clusters.reduce((max, cluster, index) => {
            const workerIndex = Math.floor(index / workBlocksPerWorker);
            const workerTime = clusters.slice(workerIndex * workBlocksPerWorker, (workerIndex + 1) * workBlocksPerWorker)
                .reduce((sum, c) => sum + c.totalTime, 0);
            return Math.max(max, workerTime);
        }, 0);
        
        const staffingText = [
            `‚Ä¢ Total work blocks generated: ${clusters.length}`,
            `‚Ä¢ Available student workers: ${AVAILABLE_WORKERS}`,
            `‚Ä¢ Work blocks per worker: ${workBlocksPerWorker} ${workBlocksPerWorker > 1 ? '(multiple shifts)' : ''}`,
            `‚Ä¢ Maximum time per worker: ~${(maxTimePerWorker/60).toFixed(1)} hours`,
            `‚Ä¢ Total project time: ${totalHours.toFixed(1)} hours`,
            clusters.length > AVAILABLE_WORKERS ? 
                '‚Ä¢ Completion timeline: 2-3 days (workers doing multiple blocks)' :
                '‚Ä¢ Completion timeline: 1 day (one block per worker)',
            '‚Ä¢ Supervision needed: Minimal (after initial briefing)',
            `‚Ä¢ Estimated labor cost: ${totalHours.toFixed(1)} hours √ó student hourly rate`
        ];
        
        staffingText.forEach(line => {
            pdf.text(line, MARGIN + 5, yPosition);
            yPosition += 6;
        });

        // Generate detailed pages for each cluster
        for (let i = 0; i < clusters.length; i++) {
            const cluster = clusters[i];
            
            // New page for each cluster
            pdf.addPage();
            yPosition = MARGIN;
            
            // Cluster header
            pdf.setFontSize(16);
            pdf.setTextColor(40);
            pdf.text(`Work Block ${i + 1}`, MARGIN, yPosition);
            yPosition += 15;
            
            // Cluster summary
            pdf.setFontSize(12);
            const totalAEDs = cluster.path.reduce((sum, building) => sum + building.aedCount, 0);
            const aedInventoryTime = totalAEDs * TIME_PER_AED;
            const aedLocationTime = cluster.path.reduce((sum, building) => sum + (building.aedLocationBuffer || AED_LOCATION_BUFFER), 0);
            const buildingNavTime = cluster.path.reduce((sum, building) => {
                const gsf = typeof building.gsf === 'number' && !isNaN(building.gsf) ? building.gsf : 0;
                return sum + (gsf > 0 ? (gsf / 50000) * TIME_PER_50K_GSF : 0);
            }, 0);
            const travelTime = cluster.totalTime - cluster.path.reduce((sum, building) => sum + building.totalTime, 0);
            
            pdf.text(`Total Time: ~${Math.round(cluster.totalTime)} minutes (${(cluster.totalTime/60).toFixed(1)} hours)`, MARGIN, yPosition);
            yPosition += 8;
            pdf.text(`Buildings: ${cluster.path.length}`, MARGIN, yPosition);
            yPosition += 8;
            pdf.text(`Total AEDs: ${totalAEDs} (assumed)`, MARGIN, yPosition);
            yPosition += 8;
            pdf.text(`AED Location Time: ~${Math.round(aedLocationTime)} minutes (variable per building)`, MARGIN, yPosition);
            yPosition += 8;
            pdf.text(`AED Inventory Time: ~${aedInventoryTime} minutes (${TIME_PER_AED} min/AED)`, MARGIN, yPosition);
            yPosition += 8;
            pdf.text(`Building Navigation: ~${Math.round(buildingNavTime)} minutes`, MARGIN, yPosition);
            yPosition += 8;
            pdf.text(`Travel Time: ~${Math.round(travelTime)} minutes`, MARGIN, yPosition);
            yPosition += 15;
            
            // Detailed Step-by-Step Table
            pdf.setFontSize(14);
            pdf.text('Step-by-Step Instructions:', MARGIN, yPosition);
            yPosition += 12;
            
            // Table headers
            pdf.setFontSize(9);
            pdf.setTextColor(40);
            pdf.text('Step', MARGIN, yPosition);
            pdf.text('Activity', MARGIN + 15, yPosition);
            pdf.text('Location', MARGIN + 65, yPosition);
            pdf.text('Time', MARGIN + 120, yPosition);
            pdf.text('Cumulative', MARGIN + 145, yPosition);
            yPosition += 5;
            
            // Table header line
            pdf.line(MARGIN, yPosition, PAGE_WIDTH - MARGIN, yPosition);
            yPosition += 8;
            
            let stepNumber = 1;
            let cumulativeTime = 0;
            
            cluster.path.forEach((building, buildingIndex) => {
                // Check if we need a new page (more conservative spacing)
                if (yPosition > (PAGE_HEIGHT - MARGIN - 60)) {
                    pdf.addPage();
                    yPosition = MARGIN;
                    // Repeat headers on new page
                    pdf.setFontSize(9);
                    pdf.setTextColor(40);
                    pdf.text('Step', MARGIN, yPosition);
                    pdf.text('Activity', MARGIN + 15, yPosition);
                    pdf.text('Location', MARGIN + 65, yPosition);
                    pdf.text('Time', MARGIN + 120, yPosition);
                    pdf.text('Cumulative', MARGIN + 145, yPosition);
                    yPosition += 5;
                    pdf.line(MARGIN, yPosition, PAGE_WIDTH - MARGIN, yPosition);
                    yPosition += 8;
                }
                
                // Travel to building (skip for first building)
                if (buildingIndex > 0) {
                    const prevBuilding = cluster.path[buildingIndex - 1];
                    const travelInfo = calculateTravelTimeSync(prevBuilding.lat, prevBuilding.lon, building.lat, building.lon);
                    const travelTime = Math.round(travelInfo.time);
                    cumulativeTime += travelTime;
                    
                    pdf.setFontSize(8);
                    pdf.setTextColor(100);
                    pdf.text(`${stepNumber}`, MARGIN, yPosition);
                    const travelMethod = travelInfo.method === 'drive' ? 'Drive to next building' : 'Walk to next building';
                    pdf.text(travelMethod, MARGIN + 15, yPosition);
                    
                    // Wrap text for location
                    const routeText = `From ${prevBuilding.code} to ${building.code}`;
                    const wrappedRoute = pdf.splitTextToSize(routeText, 50);
                    pdf.text(wrappedRoute, MARGIN + 65, yPosition);
                    
                    pdf.text(`${travelTime} min`, MARGIN + 120, yPosition);
                    pdf.text(`${cumulativeTime} min`, MARGIN + 145, yPosition);
                    yPosition += Math.max(6, wrappedRoute.length * 4);
                    stepNumber++;
                }
                
                // Navigate through building
                const buildingNavTime = building.gsf > 0 ? Math.round((building.gsf / 50000) * TIME_PER_50K_GSF) : 0;
                if (buildingNavTime > 0) {
                    cumulativeTime += buildingNavTime;
                    
                    pdf.setFontSize(8);
                    pdf.setTextColor(60);
                    pdf.text(`${stepNumber}`, MARGIN, yPosition);
                    pdf.text(`Navigate building`, MARGIN + 15, yPosition);
                    
                    // Wrap building name text
                    const buildingText = `${building.code} - ${building.name}`;
                    const wrappedBuilding = pdf.splitTextToSize(buildingText, 50);
                    pdf.text(wrappedBuilding, MARGIN + 65, yPosition);
                    
                    pdf.text(`${buildingNavTime} min`, MARGIN + 120, yPosition);
                    pdf.text(`${cumulativeTime} min`, MARGIN + 145, yPosition);
                    yPosition += Math.max(6, wrappedBuilding.length * 4);
                    stepNumber++;
                }
                
                // AED location search (variable buffer per building)
                const buildingAedLocationTime = building.aedLocationBuffer || AED_LOCATION_BUFFER;
                cumulativeTime += buildingAedLocationTime;
                
                pdf.setFontSize(8);
                pdf.setTextColor(150, 75, 0); // Orange color for search time
                pdf.text(`${stepNumber}`, MARGIN, yPosition);
                pdf.text(`Locate AEDs in building`, MARGIN + 15, yPosition);
                pdf.text(`${building.code}`, MARGIN + 65, yPosition);
                pdf.text(`${buildingAedLocationTime} min`, MARGIN + 120, yPosition);
                pdf.text(`${cumulativeTime} min`, MARGIN + 145, yPosition);
                yPosition += 6;
                stepNumber++;
                
                // AED inventory
                if (building.aedCount > 0) {
                    const aedTime = building.aedCount * TIME_PER_AED;
                    cumulativeTime += aedTime;
                    
                    pdf.setFontSize(8);
                    pdf.setTextColor(0);
                    pdf.text(`${stepNumber}`, MARGIN, yPosition);
                    pdf.text(`Inventory ${building.aedCount} AED${building.aedCount > 1 ? 's' : ''}`, MARGIN + 15, yPosition);
                    pdf.text(`${building.code}`, MARGIN + 65, yPosition);
                    pdf.text(`${aedTime} min`, MARGIN + 120, yPosition);
                    pdf.text(`${cumulativeTime} min`, MARGIN + 145, yPosition);
                    yPosition += 6;
                    stepNumber++;
                } else {
                    // Even if no AEDs expected, still document the search
                    pdf.setFontSize(8);
                    pdf.setTextColor(120);
                    pdf.text(`${stepNumber}`, MARGIN, yPosition);
                    pdf.text(`Document no AEDs found`, MARGIN + 15, yPosition);
                    pdf.text(`${building.code}`, MARGIN + 65, yPosition);
                    pdf.text(`2 min`, MARGIN + 120, yPosition);
                    cumulativeTime += 2;
                    pdf.text(`${cumulativeTime} min`, MARGIN + 145, yPosition);
                    yPosition += 6;
                    stepNumber++;
                }
                
                // Add address reference with wrapping and page break check
                pdf.setFontSize(7);
                pdf.setTextColor(120);
                const addressText = `Address: ${getBuildingAddress(building.code, building.name)}`;
                const wrappedAddress = pdf.splitTextToSize(addressText, CONTENT_WIDTH - 20);
                
                // Check if address would overflow page
                if (yPosition + (wrappedAddress.length * 4) > PAGE_HEIGHT - MARGIN - 30) {
                    pdf.addPage();
                    yPosition = MARGIN;
                    // Repeat headers on new page
                    pdf.setFontSize(9);
                    pdf.setTextColor(40);
                    pdf.text('Step', MARGIN, yPosition);
                    pdf.text('Activity', MARGIN + 15, yPosition);
                    pdf.text('Location', MARGIN + 65, yPosition);
                    pdf.text('Time', MARGIN + 120, yPosition);
                    pdf.text('Cumulative', MARGIN + 145, yPosition);
                    yPosition += 5;
                    pdf.line(MARGIN, yPosition, PAGE_WIDTH - MARGIN, yPosition);
                    yPosition += 8;
                    // Reset font for address
                    pdf.setFontSize(7);
                    pdf.setTextColor(120);
                }
                
                pdf.text(wrappedAddress, MARGIN + 15, yPosition);
                yPosition += wrappedAddress.length * 4 + 4;
                
                // Add separator line
                if (buildingIndex < cluster.path.length - 1) {
                    pdf.setDrawColor(200);
                    pdf.line(MARGIN, yPosition, PAGE_WIDTH - MARGIN, yPosition);
                    yPosition += 4;
                }
            });
            
            // Final summary row
            yPosition += 5;
            pdf.setDrawColor(0);
            pdf.line(MARGIN, yPosition, PAGE_WIDTH - MARGIN, yPosition);
            yPosition += 8;
            pdf.setFontSize(9);
            pdf.setTextColor(0);
            pdf.text('TOTAL', MARGIN + 15, yPosition);
            pdf.text(`${Math.round(cluster.totalTime)} min`, MARGIN + 120, yPosition);
            pdf.text(`(${(cluster.totalTime/60).toFixed(1)} hours)`, MARGIN + 145, yPosition);
            
            // Add map screenshot
            yPosition += 10;
            pdf.setFontSize(12);
            pdf.setTextColor(40);
            pdf.text('Route Map:', MARGIN, yPosition);
            yPosition += 10;
            
            try {
                const mapImage = await captureClusterMap(cluster, i);
                if (mapImage) {
                    // Check if we need a new page for the map
                    const mapHeight = 120; // Reasonable height for map
                    if (yPosition + mapHeight > PAGE_HEIGHT - MARGIN - 20) {
                        pdf.addPage();
                        yPosition = MARGIN;
                        pdf.setFontSize(12);
                        pdf.setTextColor(40);
                        pdf.text('Route Map:', MARGIN, yPosition);
                        yPosition += 10;
                    }
                    
                    // Add the map image to PDF with proper scaling
                    const imgWidth = CONTENT_WIDTH; // Use full content width (page width minus margins)
                    const imgHeight = mapHeight;
                    
                    // Add a border around the map for better presentation
                    pdf.setDrawColor(200);
                    pdf.rect(MARGIN - 1, yPosition - 1, imgWidth + 2, imgHeight + 2);
                    
                    pdf.addImage(mapImage, 'PNG', MARGIN, yPosition, imgWidth, imgHeight);
                    yPosition += imgHeight + 10;
                } else {
                    pdf.setFontSize(9);
                    pdf.setTextColor(100);
                    pdf.text('(Map screenshot generation failed - refer to interactive map)', MARGIN + 5, yPosition);
                    yPosition += 10;
                }
            } catch (error) {
                console.error('Map capture error:', error);
                pdf.setFontSize(9);
                pdf.setTextColor(100);
                pdf.text('(Map screenshot unavailable - refer to interactive map)', MARGIN + 5, yPosition);
                yPosition += 10;
            }
        }
        
        // Restore the full map display after generating all screenshots
        // Wait a moment to ensure map capture is complete
        await new Promise(resolve => setTimeout(resolve, 500));
        processAndDisplayData();
        
        // Save the PDF
        pdf.save('CU_Boulder_AED_Inventory_Work_Plan.pdf');
    }

    // --- GLOBAL VARIABLES EDITOR ---
    function createGlobalVarsModal() {
        const modal = document.createElement('div');
        modal.id = 'global-vars-modal';
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.5); display: none; justify-content: center; 
            align-items: center; z-index: 10000; overflow-y: auto;
        `;
        
        modal.innerHTML = `
            <div style="background: white; padding: 30px; border-radius: 10px; width: 700px; max-width: 90vw; max-height: 90vh; overflow-y: auto;">
                <h3 style="margin-top: 0; color: #2c3e50;">Edit Global Variables</h3>
                <p style="color: #7f8c8d; margin-bottom: 20px;">Customize the core assumptions and parameters used for time calculations and clustering.</p>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <div>
                        <h4 style="color: #3498db; margin-bottom: 15px; border-bottom: 2px solid #3498db; padding-bottom: 5px;">Work Planning</h4>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">Max Cluster Time (minutes):</label>
                            <input type="number" id="edit-max-cluster-time" min="60" max="600" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <small style="color: #6c757d; font-size: 0.8em;">Maximum time per work block</small>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">Available Workers:</label>
                            <input type="number" id="edit-available-workers" min="1" max="50" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <small style="color: #6c757d; font-size: 0.8em;">Number of student workers available</small>
                        </div>
                    </div>
                    
                    <div>
                        <h4 style="color: #e74c3c; margin-bottom: 15px; border-bottom: 2px solid #e74c3c; padding-bottom: 5px;">AED Inventory Times</h4>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">Time per AED (minutes):</label>
                            <input type="number" id="edit-time-per-aed" min="1" max="30" step="0.5" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <small style="color: #6c757d; font-size: 0.8em;">Inspection and documentation time</small>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">Default AED Search Buffer (minutes):</label>
                            <input type="number" id="edit-aed-buffer" min="1" max="60" step="0.5" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <small style="color: #6c757d; font-size: 0.8em;">Default time to locate AEDs in building</small>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">Time per 50k GSF (minutes):</label>
                            <input type="number" id="edit-time-per-gsf" min="0" max="10" step="0.1" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <small style="color: #6c757d; font-size: 0.8em;">Navigation time for large buildings</small>
                        </div>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <div>
                        <h4 style="color: #27ae60; margin-bottom: 15px; border-bottom: 2px solid #27ae60; padding-bottom: 5px;">Travel Parameters</h4>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">Walking Speed (mph):</label>
                            <input type="number" id="edit-walking-speed" min="1" max="5" step="0.1" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <small style="color: #6c757d; font-size: 0.8em;">Average walking speed on campus</small>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">Driving Speed (mph):</label>
                            <input type="number" id="edit-driving-speed" min="5" max="50" step="1" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <small style="color: #6c757d; font-size: 0.8em;">Average driving speed (campus/city)</small>
                        </div>
                    </div>
                    
                    <div>
                        <h4 style="color: #f39c12; margin-bottom: 15px; border-bottom: 2px solid #f39c12; padding-bottom: 5px;">Travel Thresholds</h4>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">Walking Threshold (minutes):</label>
                            <input type="number" id="edit-walking-threshold" min="5" max="60" step="1" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <small style="color: #6c757d; font-size: 0.8em;">Switch to driving if walking > X minutes</small>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">Parking Time (minutes):</label>
                            <input type="number" id="edit-parking-time" min="1" max="15" step="0.5" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <small style="color: #6c757d; font-size: 0.8em;">Additional time for parking and walking</small>
                        </div>
                    </div>
                </div>
                
                <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; border-left: 4px solid #17a2b8;">
                    <strong style="color: #17a2b8;">Impact Preview:</strong>
                    <div id="global-vars-preview" style="margin-top: 8px; font-family: monospace; font-size: 0.9em;"></div>
                </div>
                
                <div style="background: #fff3cd; padding: 12px; border-radius: 5px; margin-bottom: 20px; border-left: 4px solid #ffc107;">
                    <strong style="color: #856404;">‚ö†Ô∏è Warning:</strong>
                    <span style="color: #856404;">Changing these values will recalculate all clusters and may significantly affect work block assignments.</span>
                </div>
                
                <div style="text-align: right;">
                    <button id="cancel-global-vars" style="padding: 10px 20px; margin-right: 10px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
                    <button id="reset-global-vars" style="padding: 10px 20px; margin-right: 10px; background: #ffc107; color: #212529; border: none; border-radius: 4px; cursor: pointer;">Reset to Defaults</button>
                    <button id="save-global-vars" style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">Apply Changes</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        return modal;
    }

    function updateGlobalVarsPreview() {
        const maxClusterTime = parseInt(document.getElementById('edit-max-cluster-time').value) || MAX_CLUSTER_TIME;
        const timePerAed = parseFloat(document.getElementById('edit-time-per-aed').value) || TIME_PER_AED;
        const walkingSpeed = parseFloat(document.getElementById('edit-walking-speed').value) || WALKING_SPEED_MPH;
        const drivingSpeed = parseFloat(document.getElementById('edit-driving-speed').value) || DRIVING_SPEED_MPH;
        const walkingThreshold = parseInt(document.getElementById('edit-walking-threshold').value) || WALKING_THRESHOLD;
        
        const previewEl = document.getElementById('global-vars-preview');
        if (previewEl) {
            previewEl.innerHTML = `
                <div>‚Ä¢ Max work block time: ${maxClusterTime} minutes (${(maxClusterTime/60).toFixed(1)} hours)</div>
                <div>‚Ä¢ AED inventory: ${timePerAed} min/device</div>
                <div>‚Ä¢ Walking: ${walkingSpeed} mph (${((walkingSpeed * 1609.34) / 60).toFixed(0)} m/min)</div>
                <div>‚Ä¢ Driving: ${drivingSpeed} mph (${((drivingSpeed * 1609.34) / 60).toFixed(0)} m/min)</div>
                <div>‚Ä¢ Drive if walking > ${walkingThreshold} minutes</div>
            `;
        }
    }

    function addGlobalVarsButton() {
        const globalVarsBtn = document.createElement('button');
        globalVarsBtn.textContent = 'Edit Global Variables';
        globalVarsBtn.style.cssText = `
            display: block; width: 100%; padding: 8px; font-size: 0.9em; font-weight: bold;
            background-color: #6f42c1; color: white; border: none; border-radius: 5px;
            cursor: pointer; margin-bottom: 10px; transition: background-color 0.2s;
        `;
        globalVarsBtn.addEventListener('mouseover', () => globalVarsBtn.style.backgroundColor = '#5a32a3');
        globalVarsBtn.addEventListener('mouseout', () => globalVarsBtn.style.backgroundColor = '#6f42c1');
        
        globalVarsBtn.addEventListener('click', () => {
            let modal = document.getElementById('global-vars-modal');
            if (!modal) {
                modal = createGlobalVarsModal();
            }
            
            // Populate current values
            document.getElementById('edit-max-cluster-time').value = MAX_CLUSTER_TIME;
            document.getElementById('edit-available-workers').value = AVAILABLE_WORKERS;
            document.getElementById('edit-time-per-aed').value = TIME_PER_AED;
            document.getElementById('edit-aed-buffer').value = AED_LOCATION_BUFFER;
            document.getElementById('edit-time-per-gsf').value = TIME_PER_50K_GSF;
            document.getElementById('edit-walking-speed').value = WALKING_SPEED_MPH;
            document.getElementById('edit-driving-speed').value = DRIVING_SPEED_MPH;
            document.getElementById('edit-walking-threshold').value = WALKING_THRESHOLD;
            document.getElementById('edit-parking-time').value = PARKING_TIME;
            
            // Setup event listeners for real-time preview
            ['edit-max-cluster-time', 'edit-time-per-aed', 'edit-walking-speed', 'edit-driving-speed', 'edit-walking-threshold'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.oninput = updateGlobalVarsPreview;
                }
            });
            
            updateGlobalVarsPreview();
            modal.style.display = 'flex';
            
            // Handle save
            document.getElementById('save-global-vars').onclick = () => {
                // Update global variables
                window.MAX_CLUSTER_TIME = parseInt(document.getElementById('edit-max-cluster-time').value) || MAX_CLUSTER_TIME;
                window.AVAILABLE_WORKERS = parseInt(document.getElementById('edit-available-workers').value) || AVAILABLE_WORKERS;
                window.TIME_PER_AED = parseFloat(document.getElementById('edit-time-per-aed').value) || TIME_PER_AED;
                window.AED_LOCATION_BUFFER = parseFloat(document.getElementById('edit-aed-buffer').value) || AED_LOCATION_BUFFER;
                window.TIME_PER_50K_GSF = parseFloat(document.getElementById('edit-time-per-gsf').value) || TIME_PER_50K_GSF;
                window.WALKING_SPEED_MPH = parseFloat(document.getElementById('edit-walking-speed').value) || WALKING_SPEED_MPH;
                window.DRIVING_SPEED_MPH = parseFloat(document.getElementById('edit-driving-speed').value) || DRIVING_SPEED_MPH;
                window.WALKING_THRESHOLD = parseInt(document.getElementById('edit-walking-threshold').value) || WALKING_THRESHOLD;
                window.PARKING_TIME = parseFloat(document.getElementById('edit-parking-time').value) || PARKING_TIME;
                
                // Update derived constants
                window.METERS_PER_MINUTE_WALKING = (WALKING_SPEED_MPH * 1609.34) / 60;
                window.METERS_PER_MINUTE_DRIVING = (DRIVING_SPEED_MPH * 1609.34) / 60;
                
                // Update the constants in the global scope
                MAX_CLUSTER_TIME = window.MAX_CLUSTER_TIME;
                AVAILABLE_WORKERS = window.AVAILABLE_WORKERS;
                TIME_PER_AED = window.TIME_PER_AED;
                AED_LOCATION_BUFFER = window.AED_LOCATION_BUFFER;
                TIME_PER_50K_GSF = window.TIME_PER_50K_GSF;
                WALKING_SPEED_MPH = window.WALKING_SPEED_MPH;
                DRIVING_SPEED_MPH = window.DRIVING_SPEED_MPH;
                WALKING_THRESHOLD = window.WALKING_THRESHOLD;
                PARKING_TIME = window.PARKING_TIME;
                METERS_PER_MINUTE_WALKING = window.METERS_PER_MINUTE_WALKING;
                METERS_PER_MINUTE_DRIVING = window.METERS_PER_MINUTE_DRIVING;
                
                modal.style.display = 'none';
                
                // Regenerate clusters with new parameters
                processAndDisplayData();
            };
            
            // Handle reset to defaults
            document.getElementById('reset-global-vars').onclick = () => {
                document.getElementById('edit-max-cluster-time').value = 240;
                document.getElementById('edit-available-workers').value = 10;
                document.getElementById('edit-time-per-aed').value = 5;
                document.getElementById('edit-aed-buffer').value = 8;
                document.getElementById('edit-time-per-gsf').value = 1;
                document.getElementById('edit-walking-speed').value = 3.1;
                document.getElementById('edit-driving-speed').value = 25;
                document.getElementById('edit-walking-threshold').value = 20;
                document.getElementById('edit-parking-time').value = 3;
                updateGlobalVarsPreview();
            };
            
            // Handle cancel
            document.getElementById('cancel-global-vars').onclick = () => {
                modal.style.display = 'none';
            };
            
            // Handle click outside modal
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            };
        });
        
        document.querySelector('.button-controls').appendChild(globalVarsBtn);
    }

    // --- ADD PDF REPORT BUTTON ---
    function addPDFButton() {
        const pdfBtn = document.createElement('button');
        pdfBtn.textContent = 'Generate PDF Report';
        pdfBtn.style.cssText = `
            display: block; width: 100%; padding: 12px; font-size: 1.1em; font-weight: bold;
            background-color: #8e44ad; color: white; border: none; border-radius: 5px;
            cursor: pointer; margin-bottom: 20px; transition: background-color 0.2s;
        `;
        pdfBtn.addEventListener('mouseover', () => pdfBtn.style.backgroundColor = '#7d3c98');
        pdfBtn.addEventListener('mouseout', () => pdfBtn.style.backgroundColor = '#8e44ad');
        
        pdfBtn.addEventListener('click', async () => {
            if (currentClusters && currentClusters.length > 0) {
                const visibleClusters = getVisibleClusters();
                
                if (visibleClusters.length === 0) {
                    alert('Please make at least one cluster visible before generating a PDF report!');
                    return;
                }
                
                pdfBtn.textContent = `Generating PDF for ${visibleClusters.length} cluster(s)...`;
                pdfBtn.disabled = true;
                
                try {
                    await generatePDFReport(visibleClusters);
                    pdfBtn.textContent = 'PDF Generated!';
                    setTimeout(() => {
                        pdfBtn.textContent = 'Generate PDF Report';
                        pdfBtn.disabled = false;
                    }, 2000);
                } catch (error) {
                    console.error('PDF generation error:', error);
                    pdfBtn.textContent = 'Error - Try Again';
                    setTimeout(() => {
                        pdfBtn.textContent = 'Generate PDF Report';
                        pdfBtn.disabled = false;
                    }, 2000);
                }
            } else {
                alert('Please calculate clusters first!');
            }
        });
        
        document.querySelector('.button-controls').appendChild(pdfBtn);
        
        // Add total time summary below PDF button
        addTotalTimeSummary();
    }

    // --- ADD TOTAL TIME SUMMARY ---
    function addTotalTimeSummary() {
        const summaryDiv = document.createElement('div');
        summaryDiv.id = 'total-time-summary';
        summaryDiv.style.cssText = `
            background: #e8f5e8; border: 1px solid #c3e6c3; border-radius: 8px;
            padding: 15px; margin-bottom: 20px; text-align: center;
        `;
        
        document.querySelector('.button-controls').appendChild(summaryDiv);
        updateTotalTimeSummary();
    }

    // --- UPDATE TOTAL TIME SUMMARY ---
    function updateTotalTimeSummary() {
        const summaryDiv = document.getElementById('total-time-summary');
        if (!summaryDiv || !currentClusters || currentClusters.length === 0) return;
        
        const visibleClusters = getVisibleClusters();
        const totalMinutes = visibleClusters.reduce((sum, cluster) => sum + (cluster.totalTime || 0), 0);
        const totalHours = totalMinutes / 60;
        const avgTimePerCluster = visibleClusters.length > 0 ? totalMinutes / visibleClusters.length : 0;
        
        summaryDiv.innerHTML = `
            <div style="font-weight: bold; font-size: 1.1em; color: #2c5234; margin-bottom: 8px;">
                Total Time Estimate
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div style="flex: 1;">
                    <div style="font-size: 1.3em; font-weight: bold; color: #27ae60;">
                        ${totalHours.toFixed(1)} hours
                    </div>
                    <div style="font-size: 0.9em; color: #666;">
                        (${Math.round(totalMinutes)} minutes)
                    </div>
                </div>
                <div style="flex: 1; border-left: 1px solid #c3e6c3; padding-left: 15px;">
                    <div style="font-size: 1.1em; font-weight: bold; color: #27ae60;">
                        ${visibleClusters.length} visible blocks
                    </div>
                    <div style="font-size: 0.9em; color: #666;">
                        ${visibleClusters.length !== currentClusters.length ? `(${currentClusters.length - visibleClusters.length} hidden) ` : ''}avg ${avgTimePerCluster.toFixed(0)} min each
                    </div>
                </div>
            </div>
        `;
    }

    // --- MAP SCREENSHOT CAPTURE ---
    async function captureClusterMap(cluster, clusterIndex) {
        try {
            // Store current map state
            const originalView = map.getCenter();
            const originalZoom = map.getZoom();
            
            // Calculate bounds for this cluster
            const lats = cluster.path.map(b => b.lat);
            const lons = cluster.path.map(b => b.lon);
            const minLat = Math.min(...lats);
            const maxLat = Math.max(...lats);
            const minLon = Math.min(...lons);
            const maxLon = Math.max(...lons);
            
            // Add padding to bounds (more conservative for better framing)
            const latPadding = Math.max((maxLat - minLat) * 0.3, 0.001);
            const lonPadding = Math.max((maxLon - minLon) * 0.3, 0.001);
            const bounds = [
                [minLat - latPadding, minLon - lonPadding],
                [maxLat + latPadding, maxLon + lonPadding]
            ];
            
            // Clear all existing layers completely
            mapLayers.clearLayers();
            
            // Force map invalidation to ensure clean state
            map.invalidateSize();
            
            // Wait a moment for clearing
            await new Promise(resolve => setTimeout(resolve, 200));
            
            // Create temporary markers and route for just this cluster
            const clusterColor = BASE_COLORS[clusterIndex % BASE_COLORS.length];
            
            // Add route lines - use real routes if available, otherwise straight lines
            for (let i = 0; i < cluster.path.length - 1; i++) {
                const fromBuilding = cluster.path[i];
                const toBuilding = cluster.path[i + 1];
                
                // Check if we have real route geometry stored
                const routeKey = `${fromBuilding.code}-${toBuilding.code}`;
                let routeGeometry = null;
                
                if (window.realRoutes && window.realRoutes[routeKey]) {
                    routeGeometry = window.realRoutes[routeKey].geometry;
                }
                
                if (routeGeometry && routeGeometry.coordinates) {
                    // Draw real route using stored geometry
                    const coordinates = routeGeometry.coordinates.map(coord => [coord[1], coord[0]]); // flip lon,lat to lat,lon
                    const routeLine = L.polyline(coordinates, {
                        color: clusterColor,
                        weight: 6,
                        opacity: 0.9,
                        lineCap: 'round',
                        lineJoin: 'round'
                    });
                    routeLine.addTo(mapLayers);
                } else {
                    // Fall back to straight line
                    const routeLine = L.polyline([[fromBuilding.lat, fromBuilding.lon], [toBuilding.lat, toBuilding.lon]], {
                        color: clusterColor,
                        weight: 6,
                        opacity: 0.6,
                        dashArray: '12, 8',
                        lineCap: 'round',
                        lineJoin: 'round'
                    });
                    routeLine.addTo(mapLayers);
                }
            }
            
            // Add markers with better visibility
            cluster.path.forEach((building, buildingIndex) => {
                // Background circle for better visibility
                const backgroundMarker = L.circleMarker([building.lat, building.lon], {
                    color: 'white', 
                    weight: 3, 
                    fillColor: clusterColor, 
                    fillOpacity: 1.0, 
                    radius: 12
                }).addTo(mapLayers);
                
                // Number label with better styling
                const numberIcon = L.divIcon({
                    html: `<div style="
                        background: ${clusterColor}; 
                        color: white; 
                        border: 2px solid white;
                        border-radius: 50%; 
                        width: 24px; 
                        height: 24px; 
                        display: flex; 
                        align-items: center; 
                        justify-content: center; 
                        font-weight: bold; 
                        font-size: 14px;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                        font-family: Arial, sans-serif;
                    ">${buildingIndex + 1}</div>`,
                    className: '',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });
                
                L.marker([building.lat, building.lon], { 
                    icon: numberIcon,
                    zIndexOffset: 1000  // Ensure markers appear on top
                }).addTo(mapLayers);
                
                // Building code label with better styling
                L.marker([building.lat, building.lon], {
                    icon: L.divIcon({
                        html: `<div style="
                            background: rgba(255,255,255,0.95); 
                            padding: 3px 6px; 
                            border-radius: 4px; 
                            font-size: 11px; 
                            font-weight: bold; 
                            margin-top: 30px;
                            border: 1px solid #ccc;
                            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
                            font-family: Arial, sans-serif;
                        ">${building.code}</div>`,
                        className: '',
                        iconSize: [50, 20],
                        iconAnchor: [25, 0]
                    }),
                    zIndexOffset: 500
                }).addTo(mapLayers);
            });
            
            // Fit map to cluster bounds with more generous padding
            map.fitBounds(bounds, { 
                padding: [30, 30],
                maxZoom: 17  // Prevent zooming in too much for single buildings
            });
            
            // Wait longer for map to render and layers to load
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            // Force one more layer refresh
            mapLayers.bringToFront();
            
            // Additional wait for final rendering
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Capture the map with optimized settings
            const mapElement = document.getElementById('map');
            
            const canvas = await html2canvas(mapElement, {
                useCORS: true,
                allowTaint: false,
                backgroundColor: '#f8f9fa',
                width: 800,
                height: 500,
                scale: 1.5,  // Higher quality capture
                logging: false,
                foreignObjectRendering: true,  // Try to capture custom HTML elements
                removeContainer: false,
                imageTimeout: 30000,  // Longer timeout for image loading
                onclone: function(clonedDoc) {
                    // Ensure styles are preserved in cloned document
                    const clonedMap = clonedDoc.getElementById('map');
                    if (clonedMap) {
                        clonedMap.style.background = '#f8f9fa';
                    }
                }
            });
            
            // Restore original map state
            map.setView(originalView, originalZoom);
            
            return canvas.toDataURL('image/png', 0.9);  // Slight compression for smaller file size
            
        } catch (error) {
            console.error('Error capturing map:', error);
            return null;
        }
    }

    // --- HELPER FUNCTIONS ---
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3; // meters
        const phi1 = lat1 * Math.PI/180, phi2 = lat2 * Math.PI/180;
        const dPhi = (lat2-lat1) * Math.PI/180, dLambda = (lon2-lon1) * Math.PI/180;
        const a = Math.sin(dPhi/2) * Math.sin(dPhi/2) + Math.cos(phi1) * Math.cos(phi2) * Math.sin(dLambda/2) * Math.sin(dLambda/2);
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    // Cache for OSRM routing results to avoid repeated API calls
    const routingCache = new Map();

    async function getOSRMRoute(lat1, lon1, lat2, lon2, profile = 'foot') {
        const cacheKey = `${lat1.toFixed(6)},${lon1.toFixed(6)}-${lat2.toFixed(6)},${lon2.toFixed(6)}-${profile}`;
        
        if (routingCache.has(cacheKey)) {
            return routingCache.get(cacheKey);
        }

        try {
            const url = `https://router.project-osrm.org/route/v1/${profile}/${lon1},${lat1};${lon2},${lat2}?overview=simplified&geometries=geojson`;
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`OSRM API error: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.routes && data.routes.length > 0) {
                const route = data.routes[0];
                const result = {
                    distance: route.distance, // meters
                    duration: route.duration / 60, // convert seconds to minutes
                    geometry: route.geometry, // GeoJSON geometry for drawing route
                    success: true
                };
                
                routingCache.set(cacheKey, result);
                return result;
            } else {
                throw new Error('No route found');
            }
        } catch (error) {
            console.warn('OSRM routing failed, falling back to straight-line:', error);
            // Fallback to straight-line calculation
            const distance = calculateDistance(lat1, lon1, lat2, lon2);
            const speed = profile === 'driving' ? METERS_PER_MINUTE_DRIVING : METERS_PER_MINUTE_WALKING;
            const fallbackResult = {
                distance: distance,
                duration: distance / speed,
                geometry: null,
                success: false,
                fallback: true
            };
            
            routingCache.set(cacheKey, fallbackResult);
            return fallbackResult;
        }
    }

    async function calculateTravelTime(lat1, lon1, lat2, lon2, fromCode = null, toCode = null) {
        // Check for custom travel times first
        if (fromCode && toCode && window.customTravelTimes) {
            const travelKey = `${fromCode}-${toCode}`;
            if (window.customTravelTimes[travelKey]) {
                const custom = window.customTravelTimes[travelKey];
                return {
                    time: custom.time,
                    method: custom.method,
                    distance: calculateDistance(lat1, lon1, lat2, lon2),
                    isCustom: true,
                    geometry: null
                };
            }
        }
        
        // Try walking route first
        const walkingRoute = await getOSRMRoute(lat1, lon1, lat2, lon2, 'foot');
        const walkingTime = walkingRoute.duration;
        
        if (walkingTime > WALKING_THRESHOLD) {
            // Get driving route for longer distances
            const drivingRoute = await getOSRMRoute(lat1, lon1, lat2, lon2, 'driving');
            const drivingTime = drivingRoute.duration + PARKING_TIME;
            
            return {
                time: drivingTime,
                method: 'drive',
                distance: drivingRoute.distance,
                isCustom: false,
                geometry: drivingRoute.geometry,
                routeData: drivingRoute
            };
        } else {
            return {
                time: walkingTime,
                method: 'walk',
                distance: walkingRoute.distance,
                isCustom: false,
                geometry: walkingRoute.geometry,
                routeData: walkingRoute
            };
        }
    }

    // Legacy synchronous version for backwards compatibility
    function calculateTravelTimeSync(lat1, lon1, lat2, lon2, fromCode = null, toCode = null) {
        // Check for custom travel times first
        if (fromCode && toCode && window.customTravelTimes) {
            const travelKey = `${fromCode}-${toCode}`;
            if (window.customTravelTimes[travelKey]) {
                const custom = window.customTravelTimes[travelKey];
                return {
                    time: custom.time,
                    method: custom.method,
                    distance: calculateDistance(lat1, lon1, lat2, lon2),
                    isCustom: true
                };
            }
        }
        
        const distance = calculateDistance(lat1, lon1, lat2, lon2);
        const walkingTime = distance / METERS_PER_MINUTE_WALKING;
        
        if (walkingTime > WALKING_THRESHOLD) {
            // Use driving time + parking
            const drivingTime = distance / METERS_PER_MINUTE_DRIVING + PARKING_TIME;
            return {
                time: drivingTime,
                method: 'drive',
                distance: distance,
                isCustom: false
            };
        } else {
            return {
                time: walkingTime,
                method: 'walk',
                distance: distance,
                isCustom: false
            };
        }
    }

    function generateClusterColors(count) {
        const colors = [];
        for(let i = 0; i < count; i++) colors.push(BASE_COLORS[i % BASE_COLORS.length]);
        return colors;
    }
    
    // --- TRAVEL TIME EDITING FUNCTIONALITY ---
    function createTravelEditModal() {
        const modal = document.createElement('div');
        modal.id = 'travel-edit-modal';
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.5); display: none; justify-content: center; 
            align-items: center; z-index: 10000;
        `;
        
        modal.innerHTML = `
            <div style="background: white; padding: 30px; border-radius: 10px; width: 400px; max-width: 90vw;">
                <h3 style="margin-top: 0;">Edit Travel Time</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">From:</label>
                    <input type="text" id="travel-from" readonly style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: #f8f9fa;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">To:</label>
                    <input type="text" id="travel-to" readonly style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: #f8f9fa;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Travel Method:</label>
                    <select id="travel-method" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <option value="auto">Auto (based on distance)</option>
                        <option value="walk">Force Walking</option>
                        <option value="drive">Force Driving</option>
                    </select>
                </div>
                
                <div style="margin-bottom: 15px; background: #e8f4fd; padding: 12px; border-radius: 5px; border-left: 4px solid #17a2b8;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="use-straight-line" style="margin-right: 8px; transform: scale(1.2);">
                        <span style="font-weight: bold; color: #17a2b8;">üìê Use Straight-Line Distance</span>
                    </label>
                    <small style="color: #6c757d; font-size: 0.85em; margin-top: 5px; display: block;">
                        Perfect for buildings at the same address or when routing service gives poor results. 
                        Uses direct distance calculation instead of following roads.
                    </small>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Travel Time (minutes):</label>
                    <input type="number" id="travel-time" min="0" step="0.5" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <small style="color: #6c757d; font-size: 0.8em; margin-top: 3px; display: block;">
                        <span id="calculation-method">Using routing service calculation</span>
                    </small>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #6c757d; font-size: 0.9em;">Distance: <span id="travel-distance"></span></label>
                </div>
                <div style="text-align: right;">
                    <button id="cancel-travel-edit" style="padding: 8px 16px; margin-right: 10px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
                    <button id="save-travel-edit" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">Save Changes</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        return modal;
    }

    // Make function globally accessible
    window.editTravelTime = function(fromCode, toCode, clusterIndex) {
        console.log('Edit travel time called:', fromCode, 'to', toCode, 'cluster', clusterIndex);
        let modal = document.getElementById('travel-edit-modal');
        if (!modal) {
            modal = createTravelEditModal();
        }
        
        const fromBuilding = buildingData.find(b => b.code === fromCode);
        const toBuilding = buildingData.find(b => b.code === toCode);
        
        if (!fromBuilding || !toBuilding) return;
        
        const distance = calculateDistance(fromBuilding.lat, fromBuilding.lon, toBuilding.lat, toBuilding.lon);
        const currentTravelInfo = calculateTravelTimeSync(fromBuilding.lat, fromBuilding.lon, toBuilding.lat, toBuilding.lon);
        
        // Check if there's existing custom travel time with straight-line preference
        const travelKey = `${fromCode}-${toCode}`;
        const existingCustom = window.customTravelTimes && window.customTravelTimes[travelKey];
        const isUsingStraightLine = existingCustom && existingCustom.useStraightLine;
        
        // Populate form
        document.getElementById('travel-from').value = `${fromCode} - ${fromBuilding.name}`;
        document.getElementById('travel-to').value = `${toCode} - ${toBuilding.name}`;
        document.getElementById('travel-distance').textContent = `${(distance/1000).toFixed(2)} km`;
        document.getElementById('travel-time').value = currentTravelInfo.time.toFixed(1);
        document.getElementById('travel-method').value = existingCustom ? 
            (existingCustom.method === 'auto' ? 'auto' : existingCustom.method) : 'auto';
        document.getElementById('use-straight-line').checked = isUsingStraightLine || false;
        
        // Update calculation method display
        updateCalculationMethodDisplay();
        
        modal.style.display = 'flex';
        
        // Helper function to calculate straight-line time
        function calculateStraightLineTime(method) {
            if (method === 'walk') {
                return distance / METERS_PER_MINUTE_WALKING;
            } else if (method === 'drive') {
                return distance / METERS_PER_MINUTE_DRIVING + PARKING_TIME;
            } else { // auto
                return distance < WALKING_THRESHOLD * METERS_PER_MINUTE_WALKING ? 
                    distance / METERS_PER_MINUTE_WALKING : 
                    distance / METERS_PER_MINUTE_DRIVING + PARKING_TIME;
            }
        }
        
        // Helper function to update calculation method display
        function updateCalculationMethodDisplay() {
            const useStraightLine = document.getElementById('use-straight-line').checked;
            const method = document.getElementById('travel-method').value;
            const methodDisplay = document.getElementById('calculation-method');
            
            if (useStraightLine) {
                const methodText = method === 'auto' ? 'auto-selected' : method;
                methodDisplay.textContent = `Using straight-line ${methodText} calculation`;
                methodDisplay.style.color = '#17a2b8';
                methodDisplay.style.fontWeight = 'bold';
            } else {
                methodDisplay.textContent = 'Using routing service calculation';
                methodDisplay.style.color = '#6c757d';
                methodDisplay.style.fontWeight = 'normal';
            }
        }
        
        // Handle method change
        document.getElementById('travel-method').onchange = (e) => {
            const method = e.target.value;
            const useStraightLine = document.getElementById('use-straight-line').checked;
            
            if (useStraightLine) {
                const straightLineTime = calculateStraightLineTime(method);
                document.getElementById('travel-time').value = straightLineTime.toFixed(1);
            } else {
                if (method === 'auto') {
                    document.getElementById('travel-time').value = currentTravelInfo.time.toFixed(1);
                } else if (method === 'walk') {
                    const walkTime = distance / METERS_PER_MINUTE_WALKING;
                    document.getElementById('travel-time').value = walkTime.toFixed(1);
                } else if (method === 'drive') {
                    const driveTime = distance / METERS_PER_MINUTE_DRIVING + PARKING_TIME;
                    document.getElementById('travel-time').value = driveTime.toFixed(1);
                }
            }
            updateCalculationMethodDisplay();
        };
        
        // Handle straight-line checkbox change
        document.getElementById('use-straight-line').onchange = (e) => {
            const useStraightLine = e.target.checked;
            const method = document.getElementById('travel-method').value;
            
            if (useStraightLine) {
                const straightLineTime = calculateStraightLineTime(method);
                document.getElementById('travel-time').value = straightLineTime.toFixed(1);
            } else {
                // Revert to routing service calculation
                if (method === 'auto') {
                    document.getElementById('travel-time').value = currentTravelInfo.time.toFixed(1);
                } else {
                    // Trigger method change to recalculate
                    document.getElementById('travel-method').dispatchEvent(new Event('change'));
                }
            }
            updateCalculationMethodDisplay();
        };
        
        // Handle save
        document.getElementById('save-travel-edit').onclick = () => {
            const newTime = parseFloat(document.getElementById('travel-time').value);
            const method = document.getElementById('travel-method').value;
            const useStraightLine = document.getElementById('use-straight-line').checked;
            
            if (newTime >= 0) {
                // Store custom travel time
                const travelKey = `${fromCode}-${toCode}`;
                if (!window.customTravelTimes) window.customTravelTimes = {};
                window.customTravelTimes[travelKey] = {
                    time: newTime,
                    method: method === 'auto' ? currentTravelInfo.method : method,
                    useStraightLine: useStraightLine
                };
                
                recalculateTimesOnly();
                modal.style.display = 'none';
                
                console.log(`Saved travel time for ${fromCode}-${toCode}: ${newTime} min, method: ${method}, straight-line: ${useStraightLine}`);
            } else {
                alert('Travel time must be a positive number!');
            }
        };
        
        // Handle cancel
        document.getElementById('cancel-travel-edit').onclick = () => {
            modal.style.display = 'none';
        };
        
        // Handle click outside modal
        modal.onclick = (e) => {
            if (e.target === modal) {
                modal.style.display = 'none';
            }
        };
    };

    // --- GEOCODING FUNCTIONALITY ---
    async function geocodeAddress(address, suppressAlerts = false) {
        if (!address || address.trim() === '') {
            if (!suppressAlerts) {
                alert('Please enter an address to geocode.');
            }
            return null;
        }
        
        try {
            // Use OpenStreetMap's Nominatim service for geocoding
            const encodedAddress = encodeURIComponent(address.trim());
            const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodedAddress}&limit=1&addressdetails=1`);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data && data.length > 0) {
                const result = data[0];
                return {
                    lat: parseFloat(result.lat),
                    lon: parseFloat(result.lon),
                    display_name: result.display_name,
                    address: result.display_name
                };
            } else {
                throw new Error('No results found for this address');
            }
        } catch (error) {
            console.error('Geocoding error:', error);
            if (!suppressAlerts) {
                alert(`Could not find location for "${address}". Please check the address or enter coordinates manually.\n\nError: ${error.message}`);
            }
            return null;
        }
    }

    // Function to set default location if coordinates are missing
    function setDefaultLocation(building) {
        // Boulder, CO campus center as default
        const DEFAULT_LAT = 40.0075;
        const DEFAULT_LON = -105.2659;
        
        if (!building.lat || !building.lon || building.lat === 0 || building.lon === 0) {
            console.log(`Setting default location for building ${building.code}`);
            building.lat = DEFAULT_LAT;
            building.lon = DEFAULT_LON;
        }
        
        return building;
    }

    // --- BUILDING EDITING FUNCTIONALITY ---
    function createEditModal() {
        const modal = document.createElement('div');
        modal.id = 'edit-modal';
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.5); display: none; justify-content: center; 
            align-items: center; z-index: 10000;
        `;
        
        modal.innerHTML = `
            <div style="background: white; padding: 30px; border-radius: 10px; width: 600px; max-width: 90vw;">
                <h3 style="margin-top: 0;">Edit Building Information</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Building Code:</label>
                    <input type="text" id="edit-code" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Building Name:</label>
                    <input type="text" id="edit-name" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">GSF (Gross Square Feet):</label>
                    <input type="number" id="edit-gsf" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                <div style="display: flex; gap: 15px; margin-bottom: 15px;">
                    <div style="flex: 1;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #e74c3c;">AED Count:</label>
                        <input type="number" id="edit-aed-count" min="0" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <small style="color: #6c757d; font-size: 0.8em;">Devices to inventory (${TIME_PER_AED} min each)</small>
                    </div>
                    <div style="flex: 1;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #e74c3c;">AED Search Buffer (minutes):</label>
                        <input type="number" id="edit-aed-buffer" min="0" step="0.5" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <small style="color: #6c757d; font-size: 0.8em;">Time to locate AEDs in building</small>
                    </div>
                </div>
                <div style="background: #f8f9fa; padding: 12px; border-radius: 5px; margin-bottom: 15px; border-left: 4px solid #17a2b8;">
                    <strong style="color: #17a2b8;">Time Calculation Preview:</strong>
                    <div id="time-preview" style="margin-top: 5px; font-family: monospace; font-size: 0.9em;"></div>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #2e7d32;">üìç Building Address:</label>
                    <input type="text" id="edit-address" placeholder="Enter building address (e.g., 1234 Colorado Ave, Boulder, CO)" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <small style="color: #6c757d; font-size: 0.8em;">Address will be used for PDF reports and automatic location lookup</small>
                    <button type="button" id="geocode-address" style="margin-top: 5px; padding: 6px 12px; background: #2e7d32; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8em;">üîç Find Location</button>
                </div>
                
                <div style="display: flex; gap: 15px; margin-bottom: 15px; background: #f8f9fa; padding: 12px; border-radius: 5px; border-left: 4px solid #2e7d32;">
                    <div style="flex: 1;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #2e7d32;">üìç Latitude:</label>
                        <input type="number" id="edit-lat" step="0.000001" placeholder="e.g., 40.0150" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <small style="color: #6c757d; font-size: 0.8em;">Decimal degrees (North)</small>
                    </div>
                    <div style="flex: 1;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #2e7d32;">üìç Longitude:</label>
                        <input type="number" id="edit-lon" step="0.000001" placeholder="e.g., -105.2705" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <small style="color: #6c757d; font-size: 0.8em;">Decimal degrees (West is negative)</small>
                    </div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <div style="background: #e8f5e8; padding: 8px; border-radius: 4px; border: 1px solid #c8e6c9;">
                        <span style="color: #2e7d32; font-size: 0.85em;">
                            üí° <strong>Tip:</strong> Enter an address and click "Find Location" to automatically set lat/lon coordinates. 
                            You can also manually drag the pin on the map or enter coordinates directly.
                        </span>
                    </div>
                </div>
                
                <div id="cluster-assignment-section" style="margin-bottom: 15px; background: #fff3cd; padding: 12px; border-radius: 5px; border-left: 4px solid #ffc107; display: none;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #856404;">üîÑ Change Work Block Assignment:</label>
                    <select id="cluster-assignment" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em;">
                        <option value="">Select a work block...</option>
                    </select>
                    <small style="color: #6c757d; font-size: 0.8em; margin-top: 5px; display: block;">
                        Moving this building will update travel times and re-order the work blocks accordingly.
                    </small>
                </div>
                <div style="text-align: right;">
                    <button id="cancel-edit" style="padding: 8px 16px; margin-right: 10px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
                    <button id="save-edit" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">Save Changes</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        return modal;
    }

    // Function to update time preview in edit modal
    function updateTimePreview() {
        const aedCount = parseInt(document.getElementById('edit-aed-count').value) || 0;
        const aedBuffer = parseFloat(document.getElementById('edit-aed-buffer').value) || 0;
        const gsf = parseInt(document.getElementById('edit-gsf').value) || 0;
        
        const inventoryTime = aedCount * TIME_PER_AED;
        const inBuildingTravelTime = gsf > 0 ? (gsf / 50000) * TIME_PER_50K_GSF : 0;
        const totalTime = inventoryTime + inBuildingTravelTime + aedBuffer;
        
        const previewEl = document.getElementById('time-preview');
        if (previewEl) {
            previewEl.innerHTML = `
                <div>‚Ä¢ AED Search Buffer: ${aedBuffer} minutes</div>
                <div>‚Ä¢ AED Inventory: ${aedCount} √ó ${TIME_PER_AED} = ${inventoryTime} minutes</div>
                <div>‚Ä¢ Building Navigation: ${inBuildingTravelTime.toFixed(1)} minutes</div>
                <div style="margin-top: 5px; font-weight: bold; color: #e74c3c;">Total Building Time: ${totalTime.toFixed(1)} minutes</div>
            `;
        }
    }

    // Edit building from popup (with cluster context)
    window.editBuildingFromPopup = function(buildingCode, currentClusterIndex) {
        window.editBuilding(buildingCode, currentClusterIndex);
    };

    // Make function globally accessible  
    window.editBuilding = function(buildingCode, currentClusterIndex = null) {
        console.log('Edit building called:', buildingCode);
        const building = buildingData.find(b => b.code === buildingCode);
        if (!building) return;
        
        let modal = document.getElementById('edit-modal');
        if (!modal) {
            modal = createEditModal();
        }
        
        // Ensure building has coordinates (set defaults if missing)
        setDefaultLocation(building);
        
        // Populate form
        document.getElementById('edit-code').value = building.code;
        document.getElementById('edit-name').value = building.name;
        document.getElementById('edit-gsf').value = building.gsf || 0;
        document.getElementById('edit-aed-count').value = building.aedCount || 0;
        document.getElementById('edit-aed-buffer').value = building.aedLocationBuffer || AED_LOCATION_BUFFER;
        document.getElementById('edit-address').value = getBuildingAddress(building.code, building.name);
        document.getElementById('edit-lat').value = building.lat || '';
        document.getElementById('edit-lon').value = building.lon || '';
        
        // Handle cluster assignment section
        const clusterSection = document.getElementById('cluster-assignment-section');
        const clusterSelect = document.getElementById('cluster-assignment');
        
        if (currentClusterIndex !== null && currentClusters.length > 1) {
            // Show cluster assignment section
            clusterSection.style.display = 'block';
            
            // Clear and populate cluster options
            clusterSelect.innerHTML = '<option value="">Keep in current work block</option>';
            
            const clusterColors = generateClusterColors(currentClusters.length);
            currentClusters.forEach((cluster, index) => {
                if (index !== currentClusterIndex) {
                    const color = clusterColors[index];
                    const buildingCount = cluster.path.length;
                    const timeUsed = Math.round(cluster.totalTime);
                    const timeRemaining = MAX_CLUSTER_TIME - timeUsed;
                    
                    clusterSelect.innerHTML += `
                        <option value="${index}" style="background: ${color}20; color: ${color};">
                            Work Block ${index + 1} ‚Ä¢ ${buildingCount} buildings ‚Ä¢ ${timeUsed}/${MAX_CLUSTER_TIME} min (${timeRemaining} remaining)
                        </option>
                    `;
                }
            });
            
            // Add option to create new cluster
            clusterSelect.innerHTML += `
                <option value="new" style="background: #28a74520; color: #28a745;">
                    ‚ûï Create New Work Block
                </option>
            `;
        } else {
            // Hide cluster assignment section
            clusterSection.style.display = 'none';
        }
        
        // Setup event listeners for real-time preview
        ['edit-aed-count', 'edit-aed-buffer', 'edit-gsf'].forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.oninput = updateTimePreview;
            }
        });
        
        // Setup real-time coordinate updates
        ['edit-lat', 'edit-lon'].forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.oninput = () => {
                    const lat = parseFloat(document.getElementById('edit-lat').value);
                    const lon = parseFloat(document.getElementById('edit-lon').value);
                    
                    if (!isNaN(lat) && !isNaN(lon) && lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
                        // Update marker position in real-time if coordinates are valid
                        const marker = buildingMarkers[building.code];
                        if (marker) {
                            marker.setLatLng([lat, lon]);
                        }
                    }
                };
            }
        });
        
        // Setup geocoding button
        document.getElementById('geocode-address').onclick = async () => {
            const address = document.getElementById('edit-address').value.trim();
            if (!address) {
                alert('Please enter an address first.');
                return;
            }
            
            // Show loading state
            const button = document.getElementById('geocode-address');
            const originalText = button.textContent;
            button.textContent = 'üîÑ Finding...';
            button.disabled = true;
            
            try {
                const result = await geocodeAddress(address);
                if (result) {
                    // Update lat/lon fields
                    document.getElementById('edit-lat').value = result.lat.toFixed(6);
                    document.getElementById('edit-lon').value = result.lon.toFixed(6);
                    
                    // Optionally update address with the full formatted address
                    if (result.display_name && result.display_name !== address) {
                        const useFormattedAddress = confirm(`Found location! Would you like to use the formatted address?\n\nYour input: ${address}\nFormatted: ${result.display_name}`);
                        if (useFormattedAddress) {
                            document.getElementById('edit-address').value = result.display_name;
                        }
                    }
                    
                    alert(`‚úÖ Location found!\nLatitude: ${result.lat.toFixed(6)}\nLongitude: ${result.lon.toFixed(6)}`);
                }
            } catch (error) {
                console.error('Geocoding failed:', error);
            } finally {
                // Restore button
                button.textContent = originalText;
                button.disabled = false;
            }
        };
        
        // Initial preview update
        updateTimePreview();
        
        modal.style.display = 'flex';
        
        // Handle save
        document.getElementById('save-edit').onclick = () => {
            const newCode = document.getElementById('edit-code').value.trim();
            const newName = document.getElementById('edit-name').value.trim();
            const newGsf = parseInt(document.getElementById('edit-gsf').value) || 0;
            const newAedCount = parseInt(document.getElementById('edit-aed-count').value) || 0;
            const newAedBuffer = parseFloat(document.getElementById('edit-aed-buffer').value) || AED_LOCATION_BUFFER;
            const newAddress = document.getElementById('edit-address').value.trim();
            const newLat = parseFloat(document.getElementById('edit-lat').value);
            const newLon = parseFloat(document.getElementById('edit-lon').value);
            const newClusterAssignment = document.getElementById('cluster-assignment').value;
            
            if (newCode && newName) {
                // Validate coordinates
                if (isNaN(newLat) || isNaN(newLon)) {
                    alert('Please enter valid latitude and longitude coordinates.');
                    return;
                }
                
                if (newLat < -90 || newLat > 90) {
                    alert('Latitude must be between -90 and 90 degrees.');
                    return;
                }
                
                if (newLon < -180 || newLon > 180) {
                    alert('Longitude must be between -180 and 180 degrees.');
                    return;
                }
                
                // Update building data
                const oldCode = building.code;
                building.code = newCode;
                building.name = newName;
                building.gsf = newGsf;
                building.aedCount = newAedCount;
                building.aedLocationBuffer = newAedBuffer;
                building.lat = newLat;
                building.lon = newLon;
                
                // Update address mapping
                buildingAddresses[newCode] = newAddress;
                
                // Handle cluster reassignment
                if (newClusterAssignment !== '' && currentClusterIndex !== null) {
                    const buildingToMove = { ...building };
                    
                    // Remove from current cluster
                    const currentCluster = currentClusters[currentClusterIndex];
                    const buildingIndex = currentCluster.path.findIndex(b => b.code === oldCode);
                    if (buildingIndex !== -1) {
                        currentCluster.path.splice(buildingIndex, 1);
                        
                        // If cluster is now empty, remove it
                        if (currentCluster.path.length === 0) {
                            currentClusters.splice(currentClusterIndex, 1);
                        }
                    }
                    
                    if (newClusterAssignment === 'new') {
                        // Create new cluster
                        const newCluster = {
                            buildings: [buildingToMove],
                            path: [buildingToMove],
                            totalTime: buildingToMove.totalTime || 0
                        };
                        currentClusters.push(newCluster);
                        console.log(`Created new work block for ${newCode}`);
                    } else {
                        // Add to existing cluster
                        const targetClusterIndex = parseInt(newClusterAssignment);
                        const targetCluster = currentClusters[targetClusterIndex];
                        if (targetCluster) {
                            targetCluster.path.push(buildingToMove);
                            console.log(`Moved ${newCode} to work block ${targetClusterIndex + 1}`);
                        }
                    }
                    
                    // Mark as manually arranged
                    manuallyArranged = true;
                    
                    // Refresh the entire display
                    displayClusters();
                    
                    // Update total time summary
                    setTimeout(() => updateTotalTimeSummary(), 100);
                } else {
                    // Just update existing assignments
                    currentClusters.forEach(cluster => {
                        cluster.path.forEach(b => {
                            if (b.code === oldCode || b.code === newCode) {
                                Object.assign(b, building);
                            }
                        });
                    });
                    
                    // Recalculate times only
                    recalculateTimesOnly();
                }
                
                modal.style.display = 'none';
                
                console.log(`Building ${newCode} updated with coordinates: ${newLat}, ${newLon}`);
            } else {
                alert('Building code and name are required!');
            }
        };
        
        // Handle cancel
        document.getElementById('cancel-edit').onclick = () => {
            modal.style.display = 'none';
        };
        
        // Handle click outside modal
        modal.onclick = (e) => {
            if (e.target === modal) {
                modal.style.display = 'none';
            }
        };
    };

    // --- BUILDING DELETION FUNCTIONALITY ---
    window.deleteBuilding = function(buildingCode, clusterIndex) {
        console.log('Delete building called:', buildingCode, 'from cluster', clusterIndex);
        
        const cluster = currentClusters[clusterIndex];
        if (!cluster) {
            console.error('Cluster not found:', clusterIndex);
            return;
        }
        
        const buildingIndex = cluster.path.findIndex(b => b.code === buildingCode);
        if (buildingIndex === -1) {
            console.error('Building not found in cluster:', buildingCode);
            return;
        }
        
        const building = cluster.path[buildingIndex];
        
        // Confirmation dialog
        const confirmMessage = `Are you sure you want to delete "${building.name} (${building.code})" from Work Block ${clusterIndex + 1}?\n\nThis will remove:\n‚Ä¢ The building from the work block\n‚Ä¢ Associated travel segments\n‚Ä¢ Update all step numbers\n\nThis action cannot be undone.`;
        
        if (confirm(confirmMessage)) {
            // Remove building from cluster
            cluster.path.splice(buildingIndex, 1);
            
            // Check if cluster is now empty
            if (cluster.path.length === 0) {
                // Remove empty cluster
                currentClusters.splice(clusterIndex, 1);
                console.log('Removed empty cluster:', clusterIndex);
            }
            
            // Mark as manually arranged and recalculate
            manuallyArranged = true;
            
            // If we removed the last cluster, we need a different approach
            if (currentClusters.length === 0) {
                // No clusters left, show empty state or regenerate
                summaryContentEl.innerHTML = '<div style="text-align: center; padding: 40px; color: #6c757d;"><h3>No work blocks remaining</h3><p>All buildings have been removed. Click "Recalculate Clusters" to regenerate work blocks.</p></div>';
                mapLayers.clearLayers();
            } else {
                recalculateTimesOnly();
            }
            
            console.log(`Building ${buildingCode} deleted from cluster ${clusterIndex}`);
        }
    };

    // --- DRAG AND DROP FUNCTIONALITY ---
    function setupDragAndDrop() {
        const clusters = document.querySelectorAll('.cluster');
        
        clusters.forEach((cluster, clusterIndex) => {
            // Make cluster a drop zone
            cluster.addEventListener('dragover', (e) => {
                e.preventDefault();
                cluster.classList.add('drag-over');
            });
            
            cluster.addEventListener('dragleave', (e) => {
                if (!cluster.contains(e.relatedTarget)) {
                    cluster.classList.remove('drag-over');
                }
            });
            
            cluster.addEventListener('drop', (e) => {
                e.preventDefault();
                cluster.classList.remove('drag-over');
                
                const draggedBuildingCode = e.dataTransfer.getData('text/plain');
                const dropTarget = e.target.closest('li');
                const targetClusterIndex = parseInt(cluster.dataset.clusterIndex);
                const sourceClusterIndex = parseInt(e.dataTransfer.getData('source-cluster'));
                
                if (sourceClusterIndex !== targetClusterIndex) {
                    // Moving between clusters
                    moveBuildingBetweenClusters(draggedBuildingCode, sourceClusterIndex, targetClusterIndex);
                } else if (dropTarget && dropTarget.dataset.buildingCode !== draggedBuildingCode) {
                    // Reordering within cluster
                    reorderWithinCluster(draggedBuildingCode, dropTarget.dataset.buildingCode, targetClusterIndex);
                }
            });
            
            const listItems = cluster.querySelectorAll('li');
            listItems.forEach((li, buildingIndex) => {
                li.draggable = true;
                li.dataset.buildingCode = li.dataset.buildingCode || currentClusters[clusterIndex].path[buildingIndex].code;
                
                li.addEventListener('dragstart', (e) => {
                    li.classList.add('dragging');
                    e.dataTransfer.setData('text/plain', li.dataset.buildingCode);
                    e.dataTransfer.setData('source-cluster', clusterIndex.toString());
                });
                
                li.addEventListener('dragend', () => {
                    li.classList.remove('dragging');
                    document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                });
                
                li.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    li.classList.add('drag-over');
                });
                
                li.addEventListener('dragleave', () => {
                    li.classList.remove('drag-over');
                });
            });
        });
    }

    function moveBuildingBetweenClusters(buildingCode, sourceClusterIndex, targetClusterIndex) {
        if (sourceClusterIndex === targetClusterIndex) return;
        
        const sourceCluster = currentClusters[sourceClusterIndex];
        const targetCluster = currentClusters[targetClusterIndex];
        
        // Find and remove building from source
        const buildingIndex = sourceCluster.path.findIndex(b => b.code === buildingCode);
        if (buildingIndex === -1) return;
        
        const building = sourceCluster.path.splice(buildingIndex, 1)[0];
        
        // Add to target cluster
        targetCluster.path.push(building);
        
        manuallyArranged = true;
        recalculateTimesOnly();
    }

    function reorderWithinCluster(draggedCode, targetCode, clusterIndex) {
        const cluster = currentClusters[clusterIndex];
        const draggedIndex = cluster.path.findIndex(b => b.code === draggedCode);
        const targetIndex = cluster.path.findIndex(b => b.code === targetCode);
        
        if (draggedIndex === -1 || targetIndex === -1 || draggedIndex === targetIndex) return;
        
        // Remove dragged building
        const draggedBuilding = cluster.path.splice(draggedIndex, 1)[0];
        
        // Insert at target position
        const insertIndex = draggedIndex < targetIndex ? targetIndex : targetIndex + 1;
        cluster.path.splice(insertIndex, 0, draggedBuilding);
        
        manuallyArranged = true;
        recalculateTimesOnly();
    }

    function recalculateTimesOnly() {
        // Recalculate times for each cluster based on current arrangement
        currentClusters.forEach(cluster => {
            let totalTime = 0;
            
            cluster.path.forEach((building, index) => {
                // Recalculate building time
                const inventoryTime = building.aedCount * TIME_PER_AED;
                const gsf = typeof building.gsf === 'number' && !isNaN(building.gsf) ? building.gsf : 0;
                const inBuildingTravelTime = gsf > 0 ? (gsf / 50000) * TIME_PER_50K_GSF : 0;
                const aedLocationTime = building.aedLocationBuffer || AED_LOCATION_BUFFER;
                building.totalTime = inventoryTime + inBuildingTravelTime + aedLocationTime;
                
                totalTime += building.totalTime;
                
                // Add travel time to this building (except for first building)
                if (index > 0) {
                    const prevBuilding = cluster.path[index - 1];
                    const travelInfo = calculateTravelTimeSync(prevBuilding.lat, prevBuilding.lon, building.lat, building.lon, prevBuilding.code, building.code);
                    totalTime += travelInfo.time;
                }
            });
            
            cluster.totalTime = totalTime;
        });
        
        // Re-render display
        displayClusters();
        
        // Update total time summary
        setTimeout(() => updateTotalTimeSummary(), 100);
        
        // Reapply collision avoidance after display update
        setTimeout(() => applyMarkerCollisionAvoidance(), 200);
    }

    // --- DISPLAY CLUSTERS FUNCTION ---
    function displayClusters() {
        summaryContentEl.innerHTML = '';
        mapLayers.clearLayers();
        routeSegments = []; // Clear route segment references
        
        const clusterColors = generateClusterColors(currentClusters.length);
        const buildingMarkers = {};

        currentClusters.forEach((cluster, index) => {
            const color = clusterColors[index];
            const clusterDiv = document.createElement('div');
            clusterDiv.className = 'cluster';
            clusterDiv.style.borderColor = color;
            clusterDiv.dataset.clusterIndex = index;
            
            // Initialize visibility state if not set
            if (clusterVisibility[index] === undefined) {
                clusterVisibility[index] = true;
            }
            
            // Add visual styling for hidden clusters
            const isClusterVisible = clusterVisibility[index] !== false;
            if (!isClusterVisible) {
                clusterDiv.style.opacity = '0.6';
                clusterDiv.style.background = '#f5f5f5';
            }

            const headerDiv = document.createElement('div');
            headerDiv.className = 'cluster-header';
            headerDiv.style.backgroundColor = color;
            headerDiv.style.display = 'flex';
            headerDiv.style.justifyContent = 'space-between';
            headerDiv.style.alignItems = 'center';
            
            headerDiv.innerHTML = `
                <span>Work Block ${index + 1}</span>
                <div style="display: flex; gap: 5px; align-items: center;">
                    <button 
                        onclick="markClusterAsChecked(${index})"
                        style="background: rgba(40,167,69,0.8); border: 1px solid rgba(255,255,255,0.5); border-radius: 4px; color: white; padding: 4px 8px; font-size: 0.8em; cursor: pointer; transition: all 0.2s;"
                        title="Mark entire work block as checked"
                    >
                        ‚úÖ Check All
                    </button>
                    <button 
                        onclick="toggleClusterVisibility(${index})"
                        style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.5); border-radius: 4px; color: white; padding: 4px 8px; font-size: 0.8em; cursor: pointer; transition: all 0.2s;"
                        title="${clusterVisibility[index] ? 'Hide this cluster' : 'Show this cluster'}"
                    >
                        ${clusterVisibility[index] ? 'üëÅÔ∏è Hide' : 'üëÅÔ∏è‚Äçüó®Ô∏è Show'}
                    </button>
                </div>
            `;
            clusterDiv.appendChild(headerDiv);
            
            const ul = document.createElement('ul');
            
            cluster.path.forEach((b, buildingIndex) => {
                const stepNumber = buildingIndex + 1;
                
                // Add building step
                const li = document.createElement('li');
                li.dataset.buildingCode = b.code;
                
                // Check if building has custom settings
                const hasCustomBuffer = b.aedLocationBuffer && b.aedLocationBuffer !== AED_LOCATION_BUFFER;
                const customIndicator = hasCustomBuffer ? '<span style="color: #e67e22; font-weight: bold;">*</span>' : '';
                
                // Add checked status class to li element
                if (b.checked) {
                    li.classList.add('checked-building');
                }
                
                li.innerHTML = `
                    <div style="display: flex; align-items: center; width: 100%;">
                        <input type="checkbox" class="status-checkbox" ${b.checked ? 'checked' : ''} 
                               onchange="toggleBuildingStatus('${b.code}'); event.stopPropagation();" 
                               title="${b.checked ? 'Mark as unchecked' : 'Mark as checked'}"
                               style="margin-right: 8px; transform: scale(1.2);">
                        <span class="drag-handle">‚ãÆ‚ãÆ</span>
                        <span class="step-number">${stepNumber}</span>
                        <span class="building-name" style="${b.checked ? 'text-decoration: line-through; opacity: 0.7;' : ''}">${b.code} - ${b.name}${customIndicator}${b.locationQuestionable ? '<span style="color: #e74c3c; font-weight: bold; margin-left: 5px;" title="Location marked as questionable">‚ùì</span>' : ''}</span>
                        <div class="building-controls">
                            <span class="building-time">${Math.round(b.totalTime)} min</span>
                            <button class="edit-btn" onclick="window.editBuilding('${b.code}')">Edit</button>
                            <button class="question-btn" onclick="window.toggleQuestionable('${b.code}')" style="padding: 2px 6px; font-size: 0.7em; border: none; border-radius: 3px; cursor: pointer; transition: background-color 0.2s; background-color: ${b.locationQuestionable ? '#e74c3c' : '#f39c12'}; color: white;" title="${b.locationQuestionable ? 'Mark as confirmed location' : 'Mark location as questionable'}">?</button>
                            <button class="delete-btn" onclick="window.deleteBuilding('${b.code}', ${index})">Delete</button>
                        </div>
                    </div>`;
                li.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('edit-btn') && !e.target.classList.contains('delete-btn')) {
                        map.setView([b.lat, b.lon], 18);
                        if (buildingMarkers[b.code]) buildingMarkers[b.code].openPopup();
                    }
                });
                ul.appendChild(li);

                // Create custom marker with integrated step number
                const questionableOverlay = b.locationQuestionable ? 
                    `<div style="position: absolute; top: -5px; right: -5px; background: #e74c3c; color: white; border-radius: 50%; width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; z-index: 10; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">?</div>` : 
                    '';
                
                const combinedIcon = L.divIcon({
                    html: `
                        <div style="position: relative; width: 28px; height: 28px;">
                            <div style="background: ${color}; border: 3px solid white; border-radius: 50%; width: 28px; height: 28px; box-shadow: 0 2px 6px rgba(0,0,0,0.3); cursor: grab;"></div>
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-weight: bold; font-size: 12px; pointer-events: none;">${stepNumber}</div>
                            ${questionableOverlay}
                        </div>
                    `,
                    className: 'building-marker',
                    iconSize: [28, 28],
                    iconAnchor: [14, 14]
                });

                const marker = L.marker([b.lat, b.lon], { 
                    icon: combinedIcon,
                    draggable: true
                });
                
                // Only add to map if cluster is visible
                if (isClusterVisible) {
                    marker.addTo(mapLayers);
                }

                // Create enhanced popup content with edit button
                const popupContent = `
                    <div style="text-align: center; min-width: 200px;">
                        <div style="font-weight: bold; font-size: 1.1em; margin-bottom: 8px; color: ${color};">
                            ${b.name} (${b.code})
                        </div>
                        <div style="margin-bottom: 6px; color: #666; font-size: 0.9em;">
                            üìç ${getBuildingAddress(b.code, b.name)}
                        </div>
                        <div style="margin-bottom: 10px; padding: 4px 8px; background: ${color}; color: white; border-radius: 12px; font-size: 0.85em; display: inline-block;">
                            Work Block ${index + 1} ‚Ä¢ Step ${stepNumber}
                        </div>
                        <div style="margin-top: 8px;">
                            <button onclick="window.editBuildingFromPopup('${b.code}', ${index})" 
                                    style="background: #007bff; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9em; font-weight: bold;">
                                ‚úèÔ∏è Edit Building
                            </button>
                        </div>
                        <div style="margin-top: 6px; font-size: 0.8em; color: #999;">
                            Click to edit ‚Ä¢ Drag to move
                        </div>
                    </div>
                `;
                
                // Enhanced popup behavior: click to show/hide, with visual selection feedback
                let isDragging = false;
                
                // Click handler for popup toggle
                marker.on('click', function(e) {
                    if (!isDragging) {
                        const isCurrentlyOpen = marker.getPopup() && marker.getPopup().isOpen();
                        
                        // First, close any other open popups and reset their visual state
                        Object.values(buildingMarkers).forEach(otherMarker => {
                            if (otherMarker.getPopup() && otherMarker.getPopup().isOpen()) {
                                otherMarker.closePopup();
                                // Reset visual state of other markers
                                const otherIcon = otherMarker.getIcon();
                                if (otherIcon.options.html) {
                                    const originalHtml = otherIcon.options.html.replace(/filter: brightness\(0\.7\);\s*/g, '');
                                    otherMarker.setIcon(L.divIcon({
                                        ...otherIcon.options,
                                        html: originalHtml
                                    }));
                                }
                            }
                        });
                        
                        // Toggle popup for clicked marker
                        if (isCurrentlyOpen) {
                            // If this marker was already open, close it and deselect
                            marker.closePopup();
                            console.log(`Deselected marker for ${b.code}`);
                        } else {
                            // Show popup and darken marker
                            marker.bindPopup(popupContent, {
                                closeButton: true,
                                autoClose: false,
                                closeOnClick: false,
                                closeOnEscapeKey: true,
                                className: 'building-popup'
                            }).openPopup();
                            
                            // Darken the selected marker
                            const icon = marker.getIcon();
                            if (icon.options.html && !icon.options.html.includes('filter: brightness(0.7)')) {
                                const darkenedHtml = icon.options.html.replace('style="', 'style="filter: brightness(0.7); ');
                                marker.setIcon(L.divIcon({
                                    ...icon.options,
                                    html: darkenedHtml
                                }));
                            }
                            console.log(`Selected marker for ${b.code}`);
                        }
                    }
                });
                
                // Drag handling
                marker.on('dragstart', function(e) {
                    isDragging = true;
                    document.body.style.cursor = 'grabbing';
                    // Keep popup open during drag if it was open
                });
                
                marker.on('dragend', function(event) {
                    const newLatLng = event.target.getLatLng();
                    const buildingToUpdate = buildingData.find(bd => bd.code === b.code);
                    if (buildingToUpdate) {
                        buildingToUpdate.lat = newLatLng.lat;
                        buildingToUpdate.lon = newLatLng.lng;
                    }
                    // Update the building in current clusters too
                    b.lat = newLatLng.lat;
                    b.lon = newLatLng.lng;
                    
                    // Reset cursor and drag state
                    document.body.style.cursor = '';
                    setTimeout(() => {
                        isDragging = false;
                    }, 100);
                    
                    recalculateTimesOnly();
                });
                
                // Handle popup close events to reset visual state
                marker.on('popupclose', function(e) {
                    const icon = marker.getIcon();
                    if (icon.options.html) {
                        const originalHtml = icon.options.html.replace(/filter: brightness\(0\.7\);\s*/g, '');
                        marker.setIcon(L.divIcon({
                            ...icon.options,
                            html: originalHtml
                        }));
                    }
                });

                buildingMarkers[b.code] = marker;
                
                // Add travel segment (except for first building)
                if (buildingIndex > 0) {
                    const prevBuilding = cluster.path[buildingIndex - 1];
                    const travelInfo = calculateTravelTimeSync(prevBuilding.lat, prevBuilding.lon, b.lat, b.lon, prevBuilding.code, b.code);
                    
                    // Check if this route uses straight-line distance
                    const travelKey = `${prevBuilding.code}-${b.code}`;
                    const customTravel = window.customTravelTimes && window.customTravelTimes[travelKey];
                    const usingStraightLine = customTravel && customTravel.useStraightLine;
                    
                    const travelDiv = document.createElement('div');
                    travelDiv.className = 'travel-segment';
                    travelDiv.innerHTML = `
                        <div class="travel-info">
                            <span class="step-number">${stepNumber - 0.5}</span>
                            <span>Travel from ${prevBuilding.code} to ${b.code}</span>
                            <span class="travel-method travel-${travelInfo.method}">${travelInfo.method === 'walk' ? 'Walk' : 'Drive'}</span>
                            ${travelInfo.isCustom ? '<span style="color: #e67e22; font-weight: bold;">*</span>' : ''}
                            ${usingStraightLine ? '<span style="color: #17a2b8; font-weight: bold; margin-left: 5px;" title="Using straight-line distance calculation">üìê</span>' : ''}
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-weight: bold;">${travelInfo.time.toFixed(1)} min</span>
                            <button class="edit-travel-btn" onclick="window.editTravelTime('${prevBuilding.code}', '${b.code}', ${index})">Edit</button>
                        </div>
                    `;
                    
                    // Insert travel segment before the current building
                    ul.insertBefore(travelDiv, li);
                    
                    // Add route segment with step number
                    const routeStart = [prevBuilding.lat, prevBuilding.lon];
                    const routeEnd = [b.lat, b.lon];
                    
                    // Check if campus mode is enabled
                    const campusMode = document.getElementById('campus-mode') && document.getElementById('campus-mode').checked;
                    
                    const routeSegment = L.polyline([routeStart, routeEnd], { 
                        color: color, 
                        weight: campusMode ? 3 : 4, 
                        opacity: campusMode ? 0.9 : 0.8, 
                        dashArray: campusMode ? null : (travelInfo.method === 'drive' ? '10, 5' : null),
                        lineCap: campusMode ? 'round' : 'butt',
                        lineJoin: campusMode ? 'round' : 'miter'
                    });
                    
                    // Add step number at midpoint of route
                    const midLat = (routeStart[0] + routeEnd[0]) / 2;
                    const midLon = (routeStart[1] + routeEnd[1]) / 2;
                    
                    const routeStepIcon = L.divIcon({
                        html: `<div style="background: white; color: ${color}; border: 2px solid ${color}; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">${stepNumber - 0.5}</div>`,
                        className: '',
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });
                    
                    const stepMarker = L.marker([midLat, midLon], { icon: routeStepIcon });
                    
                    // Only add to map if cluster is visible
                    if (isClusterVisible) {
                        routeSegment.addTo(mapLayers);
                        stepMarker.addTo(mapLayers);
                    }
                    
                    // Store references for later replacement with actual routes
                    routeSegments.push({
                        clusterIndex: index,
                        buildingIndex: buildingIndex,
                        routeLine: routeSegment,
                        stepMarker: stepMarker,
                        fromBuilding: prevBuilding,
                        toBuilding: b,
                        color: color,
                        stepNumber: stepNumber
                    });
                }
            });
            clusterDiv.appendChild(ul);

            const totalTimeDiv = document.createElement('div');
            totalTimeDiv.className = 'total-time';
            totalTimeDiv.innerHTML = `Total Block Time: <span style="color: ${color};">${Math.round(cluster.totalTime)}</span> / ${MAX_CLUSTER_TIME} min`;
            clusterDiv.appendChild(totalTimeDiv);
            summaryContentEl.appendChild(clusterDiv);
        });
        
        // Add legend for custom indicators
        const hasAnyCustomSettings = currentClusters.some(cluster => 
            cluster.path.some(building => 
                (building.aedLocationBuffer && building.aedLocationBuffer !== AED_LOCATION_BUFFER)
            )
        );
        
        const hasQuestionableLocations = currentClusters.some(cluster =>
            cluster.path.some(building => building.locationQuestionable)
        );
        
        const hasStraightLineRoutes = currentClusters.some(cluster => {
            for (let i = 1; i < cluster.path.length; i++) {
                const prevBuilding = cluster.path[i - 1];
                const currentBuilding = cluster.path[i];
                const travelKey = `${prevBuilding.code}-${currentBuilding.code}`;
                const customTravel = window.customTravelTimes && window.customTravelTimes[travelKey];
                if (customTravel && customTravel.useStraightLine) {
                    return true;
                }
            }
            return false;
        });
        
        // Check if campus mode is enabled
        const campusMode = document.getElementById('campus-mode') && document.getElementById('campus-mode').checked;
        
        if (hasAnyCustomSettings || hasQuestionableLocations || hasStraightLineRoutes || campusMode) {
            const legendDiv = document.createElement('div');
            legendDiv.style.cssText = `
                margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px;
                border-left: 4px solid #e67e22; font-size: 0.85em; color: #6c757d;
            `;
            
            let legendContent = '<strong style="color: #e67e22;">Legend:</strong><br>';
            
            if (campusMode) {
                legendContent += '<span style="color: #28a745; font-weight: bold;">üè´</span> = Campus mode active (direct path routing)<br>';
            }
            
            if (hasAnyCustomSettings) {
                legendContent += '<span style="color: #e67e22; font-weight: bold;">*</span> = Building has custom AED search buffer time<br>';
            }
            
            if (hasQuestionableLocations) {
                legendContent += '<span style="color: #e74c3c; font-weight: bold;">‚ùì</span> = Location marked as questionable<br>';
            }
            
            if (hasStraightLineRoutes && !campusMode) {
                legendContent += '<span style="color: #17a2b8; font-weight: bold;">üìê</span> = Route uses straight-line distance calculation<br>';
            }
            
            legendDiv.innerHTML = legendContent;
            summaryContentEl.appendChild(legendDiv);
        }
        
        // Add cluster visibility controls
        addClusterVisibilityControls();
        
        // Setup drag and drop after rendering
        setTimeout(() => setupDragAndDrop(), 100);
        
        // Apply collision detection and marker spreading after initial rendering
        setTimeout(() => applyMarkerCollisionAvoidance(), 200);
        
        // Setup rectangle selection after rendering
        setupRectangleSelection();
    }

    // --- ADD CLUSTER VISIBILITY CONTROLS ---
    function addClusterVisibilityControls() {
        const existingControls = document.getElementById('cluster-visibility-controls');
        if (existingControls) {
            existingControls.remove();
        }
        
        const controlsDiv = document.createElement('div');
        controlsDiv.id = 'cluster-visibility-controls';
        controlsDiv.style.cssText = `
            margin-bottom: 15px; padding: 10px; background: #e8f4fd; border: 1px solid #b3d9ff; 
            border-radius: 5px; text-align: center;
        `;
        
        const visibleClusters = getVisibleClusters();
        const allVisible = visibleClusters.length === currentClusters.length;
        
        controlsDiv.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 8px; color: #0066cc;">
                Cluster Visibility (${visibleClusters.length}/${currentClusters.length} visible)
            </div>
            <button onclick="toggleAllClusters(${allVisible ? 'false' : 'true'})" 
                    style="background: #0066cc; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; margin-right: 8px;">
                ${allVisible ? 'Hide All' : 'Show All'}
            </button>
            <span style="font-size: 0.85em; color: #666;">
                Use individual cluster buttons to show/hide specific work blocks<br>
                <strong>Tip:</strong> Hold <kbd style="background: #f1f1f1; padding: 1px 4px; border-radius: 2px; font-size: 0.9em;">Shift</kbd> + drag on map to select multiple markers
            </span>
        `;
        
        // Insert before the first cluster
        const firstCluster = summaryContentEl.querySelector('.cluster');
        if (firstCluster) {
            summaryContentEl.insertBefore(controlsDiv, firstCluster);
        } else {
            summaryContentEl.appendChild(controlsDiv);
        }
    }

    // --- TOGGLE ALL CLUSTERS ---
    window.toggleAllClusters = function(showAll) {
        currentClusters.forEach((cluster, index) => {
            clusterVisibility[index] = showAll;
        });
        
        displayClusters();
        
        setTimeout(() => {
            applyMarkerCollisionAvoidance();
            setupRectangleSelection();
            updateTotalTimeSummary();
        }, 200);
    };

    // --- RECTANGLE SELECTION SYSTEM ---
    function setupRectangleSelection() {
        // Clear any existing event listeners
        map.off('mousedown');
        map.off('mousemove');
        map.off('mouseup');
        
        let startLatLng = null;
        
        map.on('mousedown', function(e) {
            // Only start selection if Shift key is held down and clicking on empty map (not on a marker)
            if (!e.originalEvent.shiftKey || 
                e.originalEvent.target.tagName.toLowerCase() !== 'div' || 
                e.originalEvent.target.closest('.leaflet-marker-icon')) {
                return;
            }
            
            isSelecting = true;
            startLatLng = e.latlng;
            selectionStartPoint = map.latLngToContainerPoint(e.latlng);
            
            // Clear previous selection
            clearSelection();
            
            e.originalEvent.preventDefault();
        });
        
        map.on('mousemove', function(e) {
            if (!isSelecting || !startLatLng) return;
            
            const currentPoint = map.latLngToContainerPoint(e.latlng);
            
            // Remove existing selection rectangle
            if (selectionRectangle) {
                map.removeLayer(selectionRectangle);
            }
            
            // Create selection rectangle
            const bounds = L.latLngBounds(startLatLng, e.latlng);
            selectionRectangle = L.rectangle(bounds, {
                color: '#007bff',
                weight: 2,
                opacity: 0.8,
                fillOpacity: 0.1,
                dashArray: '5, 5'
            }).addTo(map);
        });
        
        map.on('mouseup', function(e) {
            if (!isSelecting || !startLatLng) return;
            
            const endLatLng = e.latlng;
            const bounds = L.latLngBounds(startLatLng, endLatLng);
            
            // Find markers within selection
            mapLayers.eachLayer(layer => {
                if (layer instanceof L.Marker && layer.options.icon && 
                    layer.options.icon.options.className === 'building-marker') {
                    const markerLatLng = layer.getLatLng();
                    if (bounds.contains(markerLatLng)) {
                        selectedMarkers.add(layer);
                        highlightSelectedMarker(layer);
                    }
                }
            });
            
            // Clean up
            if (selectionRectangle) {
                map.removeLayer(selectionRectangle);
                selectionRectangle = null;
            }
            
            isSelecting = false;
            startLatLng = null;
            
            if (selectedMarkers.size > 0) {
                console.log(`Selected ${selectedMarkers.size} markers`);
                setupGroupDragging();
            }
        });
    }
    
    function clearSelection() {
        selectedMarkers.forEach(marker => {
            unhighlightSelectedMarker(marker);
        });
        selectedMarkers.clear();
        isDraggingGroup = false;
    }
    
    function highlightSelectedMarker(marker) {
        // Add a blue border to selected markers
        const icon = marker.getIcon();
        if (icon && icon.options.html) {
            const newHtml = icon.options.html.replace(
                'border: 3px solid white;',
                'border: 3px solid #007bff; box-shadow: 0 0 10px #007bff;'
            );
            const newIcon = L.divIcon({
                html: newHtml,
                className: icon.options.className,
                iconSize: icon.options.iconSize,
                iconAnchor: icon.options.iconAnchor
            });
            marker.setIcon(newIcon);
        }
    }
    
    function unhighlightSelectedMarker(marker) {
        // Remove blue border from deselected markers
        const icon = marker.getIcon();
        if (icon && icon.options.html) {
            const newHtml = icon.options.html.replace(
                /border: 3px solid #007bff; box-shadow: 0 0 10px #007bff;/g,
                'border: 3px solid white;'
            );
            const newIcon = L.divIcon({
                html: newHtml,
                className: icon.options.className,
                iconSize: icon.options.iconSize,
                iconAnchor: icon.options.iconAnchor
            });
            marker.setIcon(newIcon);
        }
    }
    
    function setupGroupDragging() {
        selectedMarkers.forEach(marker => {
            marker.off('dragstart');
            marker.off('drag');
            marker.off('dragend');
            
            marker.on('dragstart', function(e) {
                isDraggingGroup = true;
                document.body.style.cursor = 'grabbing';
            });
            
            marker.on('drag', function(e) {
                if (!isDraggingGroup) return;
                
                const draggedMarker = e.target;
                const draggedLatLng = draggedMarker.getLatLng();
                const originalLatLng = draggedMarker._originalPosition || draggedLatLng;
                
                if (!draggedMarker._originalPosition) {
                    draggedMarker._originalPosition = originalLatLng;
                }
                
                const deltaLat = draggedLatLng.lat - originalLatLng.lat;
                const deltaLng = draggedLatLng.lng - originalLatLng.lng;
                
                // Move other selected markers
                selectedMarkers.forEach(otherMarker => {
                    if (otherMarker !== draggedMarker) {
                        const otherOriginal = otherMarker._originalPosition || otherMarker.getLatLng();
                        if (!otherMarker._originalPosition) {
                            otherMarker._originalPosition = otherOriginal;
                        }
                        
                        const newLatLng = L.latLng(
                            otherOriginal.lat + deltaLat,
                            otherOriginal.lng + deltaLng
                        );
                        otherMarker.setLatLng(newLatLng);
                    }
                });
            });
            
            marker.on('dragend', function(e) {
                if (!isDraggingGroup) return;
                
                // Update building data for all moved markers
                selectedMarkers.forEach(movedMarker => {
                    const newLatLng = movedMarker.getLatLng();
                    
                    // Find the building data and update coordinates
                    const markerHtml = movedMarker.getIcon().options.html;
                    const stepMatch = markerHtml.match(/>(\\d+)</);
                    if (stepMatch) {
                        const stepNumber = parseInt(stepMatch[1]);
                        
                        // Find the building in current clusters
                        currentClusters.forEach(cluster => {
                            if (cluster.path[stepNumber - 1]) {
                                const building = cluster.path[stepNumber - 1];
                                const buildingToUpdate = buildingData.find(bd => bd.code === building.code);
                                if (buildingToUpdate) {
                                    buildingToUpdate.lat = newLatLng.lat;
                                    buildingToUpdate.lon = newLatLng.lng;
                                }
                                building.lat = newLatLng.lat;
                                building.lon = newLatLng.lng;
                            }
                        });
                    }
                    
                    movedMarker._originalPosition = null;
                });
                
                document.body.style.cursor = '';
                isDraggingGroup = false;
                
                // Clear selection after drag
                setTimeout(() => {
                    clearSelection();
                    recalculateTimesOnly();
                }, 100);
                         });
         });
     }

    // --- QUESTIONABLE LOCATION SYSTEM ---
    window.toggleQuestionable = function(buildingCode) {
        console.log('Toggle questionable called for:', buildingCode);
        
        // Find building in buildingData
        const building = buildingData.find(b => b.code === buildingCode);
        if (building) {
            building.locationQuestionable = !building.locationQuestionable;
            console.log(`Building ${buildingCode} questionable status: ${building.locationQuestionable}`);
        }
        
        // Find building in current clusters and update
        currentClusters.forEach(cluster => {
            cluster.path.forEach(b => {
                if (b.code === buildingCode) {
                    b.locationQuestionable = building.locationQuestionable;
                }
            });
        });
        
        // Refresh display to show changes
        displayClusters();
        
        // Reapply collision avoidance and selection
        setTimeout(() => {
            applyMarkerCollisionAvoidance();
            setupRectangleSelection();
        }, 200);
    };

    // --- CLUSTER VISIBILITY SYSTEM ---
    window.toggleClusterVisibility = function(clusterIndex) {
        console.log('Toggling visibility for cluster', clusterIndex);
        
        // Toggle visibility state
        clusterVisibility[clusterIndex] = !clusterVisibility[clusterIndex];
        
        // Refresh display to show/hide cluster elements
        displayClusters();
        
        // Reapply other systems
        setTimeout(() => {
            applyMarkerCollisionAvoidance();
            setupRectangleSelection();
            updateTotalTimeSummary();
        }, 200);
    };

    // Get visible clusters for PDF generation
    function getVisibleClusters() {
        return currentClusters.filter((cluster, index) => clusterVisibility[index] !== false);
    }

    // --- ENHANCE ROUTES WITH ACTUAL PATHS ---
    async function enhanceRoutesWithActualPaths() {
        // This function will replace straight-line routes with actual route geometry
        console.log('Starting route enhancement for', routeSegments.length, 'route segments');
        
        const campusMode = document.getElementById('campus-mode').checked;
        if (campusMode) {
            console.log('Campus mode enabled - keeping direct path routing');
            // In campus mode, just update times but keep straight-line routes
            updateSidebarDisplay();
            updateTotalTimeSummary();
            return;
        }
        
        for (let i = 0; i < routeSegments.length; i++) {
            const segment = routeSegments[i];
            
            try {
                // Get actual route data
                const routeData = await calculateTravelTime(
                    segment.fromBuilding.lat, segment.fromBuilding.lon, 
                    segment.toBuilding.lat, segment.toBuilding.lon, 
                    segment.fromBuilding.code, segment.toBuilding.code
                );
                
                if (routeData.geometry && routeData.geometry.coordinates) {
                    console.log(`Replacing route from ${segment.fromBuilding.code} to ${segment.toBuilding.code} with actual geometry`);
                    
                    // Store actual route time for sidebar updates
                    const routeKey = `${segment.fromBuilding.code}-${segment.toBuilding.code}`;
                    actualRouteTimes[routeKey] = routeData.time;
                    
                    // Remove the old straight-line route and step marker
                    mapLayers.removeLayer(segment.routeLine);
                    mapLayers.removeLayer(segment.stepMarker);
                    
                    // Create new route with actual geometry
                    const coordinates = routeData.geometry.coordinates.map(coord => [coord[1], coord[0]]); // GeoJSON uses [lon, lat], Leaflet uses [lat, lon]
                    
                    const actualRoute = L.polyline(coordinates, {
                        color: segment.color,
                        weight: 4,
                        opacity: 0.8,
                        dashArray: routeData.method === 'drive' ? '10, 5' : null
                    }).addTo(mapLayers);
                    
                    // Add popup with route info
                    const routeInfo = `
                        <b>Route: ${segment.fromBuilding.code} ‚Üí ${segment.toBuilding.code}</b><br>
                        Method: ${routeData.method === 'walk' ? 'Walking' : 'Driving'}<br>
                        Distance: ${(routeData.distance / 1000).toFixed(2)} km<br>
                        Time: ${routeData.time.toFixed(1)} minutes
                    `;
                    actualRoute.bindPopup(routeInfo);
                    
                    // Add step number at midpoint of actual route
                    const midIndex = Math.floor(coordinates.length / 2);
                    const midPoint = coordinates[midIndex];
                    
                    const routeStepIcon = L.divIcon({
                        html: `<div style="background: white; color: ${segment.color}; border: 2px solid ${segment.color}; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">${segment.stepNumber - 0.5}</div>`,
                        className: '',
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });
                    
                    L.marker(midPoint, { icon: routeStepIcon }).addTo(mapLayers);
                } else {
                    console.warn(`No geometry available for route from ${segment.fromBuilding.code} to ${segment.toBuilding.code}`);
                }
            } catch (error) {
                console.warn(`Failed to get route geometry for ${segment.fromBuilding.code} to ${segment.toBuilding.code}:`, error);
                // Keep the straight line if route fetching fails
            }
            
            // Add a small delay to avoid overwhelming the routing service
            await new Promise(resolve => setTimeout(resolve, 150));
        }
        
        console.log('Route enhancement complete');
        
        // Update sidebar with actual route times
        updateSidebarWithActualTimes();
    }

    // --- UPDATE SIDEBAR WITH ACTUAL ROUTE TIMES ---
    function updateSidebarWithActualTimes() {
        // Recalculate cluster times with actual route data
        currentClusters.forEach((cluster, clusterIndex) => {
            let totalTime = 0;
            
            cluster.path.forEach((building, buildingIndex) => {
                // Add building work time
                const inventoryTime = building.aedCount * TIME_PER_AED;
                const gsf = typeof building.gsf === 'number' && !isNaN(building.gsf) ? building.gsf : 0;
                const inBuildingTravelTime = gsf > 0 ? (gsf / 50000) * TIME_PER_50K_GSF : 0;
                const aedLocationTime = building.aedLocationBuffer || AED_LOCATION_BUFFER;
                building.totalTime = inventoryTime + inBuildingTravelTime + aedLocationTime;
                totalTime += building.totalTime;
                
                // Add actual travel time (except for first building)
                if (buildingIndex > 0) {
                    const prevBuilding = cluster.path[buildingIndex - 1];
                    const routeKey = `${prevBuilding.code}-${building.code}`;
                    
                    if (actualRouteTimes[routeKey]) {
                        // Use actual route time
                        totalTime += actualRouteTimes[routeKey];
                        console.log(`Using actual time ${actualRouteTimes[routeKey].toFixed(1)} min for ${routeKey}`);
                    } else {
                        // Fall back to calculated time
                        const travelInfo = calculateTravelTimeSync(prevBuilding.lat, prevBuilding.lon, building.lat, building.lon, prevBuilding.code, building.code);
                        totalTime += travelInfo.time;
                    }
                }
            });
            
            cluster.totalTime = totalTime;
        });
        
        // Update the visual display with new times
        updateSidebarDisplay();
        updateTotalTimeSummary();
    }

    // --- UPDATE SIDEBAR DISPLAY ---
    function updateSidebarDisplay() {
        currentClusters.forEach((cluster, clusterIndex) => {
            // Update cluster total time display
            const clusterDiv = document.querySelector(`[data-cluster-index="${clusterIndex}"]`);
            if (clusterDiv) {
                const totalTimeDiv = clusterDiv.querySelector('.total-time');
                if (totalTimeDiv) {
                    const color = BASE_COLORS[clusterIndex % BASE_COLORS.length];
                    totalTimeDiv.innerHTML = `Total Block Time: <span style="color: ${color};">${Math.round(cluster.totalTime)}</span> / ${MAX_CLUSTER_TIME} min`;
                }
            }
            
            // Update individual travel time displays
            cluster.path.forEach((building, buildingIndex) => {
                if (buildingIndex > 0) {
                    const prevBuilding = cluster.path[buildingIndex - 1];
                    const routeKey = `${prevBuilding.code}-${building.code}`;
                    
                    if (actualRouteTimes[routeKey]) {
                        // Find and update the travel segment display
                        const travelSegments = document.querySelectorAll('.travel-segment');
                        travelSegments.forEach(segment => {
                            const travelText = segment.textContent;
                            if (travelText.includes(`Travel from ${prevBuilding.code} to ${building.code}`)) {
                                const timeSpan = segment.querySelector('span[style*="font-weight: bold"]');
                                if (timeSpan) {
                                    timeSpan.textContent = `${actualRouteTimes[routeKey].toFixed(1)} min`;
                                    // Add indicator that this is actual route time
                                    if (!segment.querySelector('.actual-time-indicator')) {
                                        const indicator = document.createElement('span');
                                        indicator.className = 'actual-time-indicator';
                                        indicator.style.cssText = 'color: #27ae60; font-weight: bold; margin-left: 5px; font-size: 0.8em;';
                                        indicator.textContent = '‚úì';
                                        indicator.title = 'Updated with actual route time';
                                        timeSpan.parentNode.appendChild(indicator);
                                    }
                                }
                            }
                        });
                    }
                }
            });
        });
    }

    // --- MARKER COLLISION AVOIDANCE SYSTEM ---
    function applyMarkerCollisionAvoidance() {
        // Get all markers from the map
        const markers = [];
        const markerData = [];
        
        mapLayers.eachLayer(layer => {
            if (layer instanceof L.Marker && layer.options.icon && layer.options.icon.options.className === 'building-marker') {
                markers.push(layer);
                const latLng = layer.getLatLng();
                markerData.push({
                    marker: layer,
                    originalLat: latLng.lat,
                    originalLng: latLng.lng,
                    currentLat: latLng.lat,
                    currentLng: latLng.lng,
                    moved: false
                });
            }
        });
        
        if (markers.length <= 1) return; // No collision possible with 1 or fewer markers
        
        // Collision detection parameters
        const COLLISION_DISTANCE_METERS = 8; // Minimum distance between markers in meters (just enough to avoid visual overlap)
        const MAX_ITERATIONS = 10; // Prevent infinite loops
        const SPREAD_MULTIPLIER = 1.1; // How much to spread apart colliding markers (minimal spacing)
        
        // Iteratively resolve collisions
        for (let iteration = 0; iteration < MAX_ITERATIONS; iteration++) {
            let collisionsFound = false;
            
            // Check all pairs of markers for collisions
            for (let i = 0; i < markerData.length; i++) {
                for (let j = i + 1; j < markerData.length; j++) {
                    const marker1 = markerData[i];
                    const marker2 = markerData[j];
                    
                    const distance = calculateDistance(
                        marker1.currentLat, marker1.currentLng,
                        marker2.currentLat, marker2.currentLng
                    );
                    
                    if (distance < COLLISION_DISTANCE_METERS) {
                        collisionsFound = true;
                        
                        // Calculate midpoint between the two markers
                        const midLat = (marker1.currentLat + marker2.currentLat) / 2;
                        const midLng = (marker1.currentLng + marker2.currentLng) / 2;
                        
                        // Calculate separation vector
                        const deltaLat = marker2.currentLat - marker1.currentLat;
                        const deltaLng = marker2.currentLng - marker1.currentLng;
                        
                        // If markers are exactly on top of each other, create arbitrary separation
                        let separationLat, separationLng;
                        if (Math.abs(deltaLat) < 0.000001 && Math.abs(deltaLng) < 0.000001) {
                            separationLat = 0.0001 * (Math.random() - 0.5);
                            separationLng = 0.0001 * (Math.random() - 0.5);
                        } else {
                            // Normalize and scale the separation vector
                            const length = Math.sqrt(deltaLat * deltaLat + deltaLng * deltaLng);
                            separationLat = (deltaLat / length) * 0.0002 * SPREAD_MULTIPLIER;
                            separationLng = (deltaLng / length) * 0.0002 * SPREAD_MULTIPLIER;
                        }
                        
                        // Move markers apart from their midpoint
                        marker1.currentLat = midLat - separationLat;
                        marker1.currentLng = midLng - separationLng;
                        marker2.currentLat = midLat + separationLat;
                        marker2.currentLng = midLng + separationLng;
                        
                        marker1.moved = true;
                        marker2.moved = true;
                    }
                }
            }
            
            // If no collisions found, we're done
            if (!collisionsFound) break;
        }
        
        // Update marker positions and add connection lines for moved markers
        markerData.forEach(data => {
            if (data.moved) {
                // Update marker position
                data.marker.setLatLng([data.currentLat, data.currentLng]);
                
                // Add a subtle connection line from original to new position
                const connectionLine = L.polyline([
                    [data.originalLat, data.originalLng],
                    [data.currentLat, data.currentLng]
                ], {
                    color: '#666666',
                    weight: 1,
                    opacity: 0.4,
                    dashArray: '2, 4'
                }).addTo(mapLayers);
                
                // Add a small dot at the original location
                const originalLocationDot = L.circleMarker([data.originalLat, data.originalLng], {
                    radius: 3,
                    fillColor: '#666666',
                    color: '#ffffff',
                    weight: 1,
                    opacity: 0.7,
                    fillOpacity: 0.5
                }).addTo(mapLayers);
                
                // Add tooltip to the original location dot
                originalLocationDot.bindTooltip('Actual building location', {
                    permanent: false,
                    direction: 'bottom',
                    offset: [0, 5]
                });
            }
        });
    }

    // --- MAIN PROCESSING AND RENDERING FUNCTION ---
    function processAndDisplayData() {
        loaderEl.style.display = 'block';
        summaryContentEl.innerHTML = '';
        mapLayers.clearLayers();
        manuallyArranged = false;

        // Use a timeout to allow the browser to render the loader before the heavy computation
        setTimeout(() => {
            let processedBuildingData = JSON.parse(JSON.stringify(buildingData));

            processedBuildingData.forEach(b => {
                // Ensure building has coordinates (set defaults if missing)
                setDefaultLocation(b);
                
                const inventoryTime = b.aedCount * TIME_PER_AED;
                const gsf = typeof b.gsf === 'number' && !isNaN(b.gsf) ? b.gsf : 0;
                const inBuildingTravelTime = gsf > 0 ? (gsf / 50000) * TIME_PER_50K_GSF : 0;
                const aedLocationTime = b.aedLocationBuffer || AED_LOCATION_BUFFER;
                b.totalTime = inventoryTime + inBuildingTravelTime + aedLocationTime;
                b.assigned = false;
            });

            const clusters = [];
            let unassignedBuildings = processedBuildingData.filter(b => b.lat != null && b.lon != null);

            while (unassignedBuildings.length > 0) {
                let currentCluster = { buildings: [], totalTime: 0, path: [] };
                unassignedBuildings.sort((a, b) => (b.lat - a.lat) || (a.lon - b.lon));
                
                let startBuilding = unassignedBuildings.shift();
                startBuilding.assigned = true;

                let lastBuilding = startBuilding;
                currentCluster.buildings.push(startBuilding);
                currentCluster.totalTime += startBuilding.totalTime;
                currentCluster.path.push(startBuilding);

                let potentialAddition = true;
                while(potentialAddition && unassignedBuildings.length > 0) {
                    potentialAddition = false;
                    let nearest = null, minDistance = Infinity, nearestIndex = -1;

                    for (let i = 0; i < unassignedBuildings.length; i++) {
                        const distance = calculateDistance(lastBuilding.lat, lastBuilding.lon, unassignedBuildings[i].lat, unassignedBuildings[i].lon);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearest = unassignedBuildings[i];
                            nearestIndex = i;
                        }
                    }

                    if (nearest) {
                        const travelInfo = calculateTravelTimeSync(lastBuilding.lat, lastBuilding.lon, nearest.lat, nearest.lon, lastBuilding.code, nearest.code);
                        if (currentCluster.totalTime + travelInfo.time + nearest.totalTime <= MAX_CLUSTER_TIME) {
                            currentCluster.totalTime += travelInfo.time + nearest.totalTime;
                            currentCluster.path.push(nearest);
                            lastBuilding = nearest;
                            potentialAddition = true;
                            unassignedBuildings.splice(nearestIndex, 1);
                        }
                    }
                }
                clusters.push(currentCluster);
            }
            
            // Store clusters globally for PDF generation
            currentClusters = clusters;
            
            loaderEl.style.display = 'none';
            displayClusters();
            // Update total time summary after initial display
            setTimeout(() => updateTotalTimeSummary(), 100);
            // Enhance routes with actual geometry after initial display
            enhanceRoutesWithActualPaths();
        }, 50);
    }

    // --- SAVE/LOAD SYSTEM ---
    async function saveStateToCSV() {
        try {
            const csvData = [];
            
            // Header with metadata
            csvData.push(['# CU Boulder AED Inventory State File']);
            csvData.push(['# Generated:', new Date().toISOString()]);
            csvData.push(['']);
            
            // Global settings
            csvData.push(['# GLOBAL_SETTINGS']);
            csvData.push(['MAX_CLUSTER_TIME', MAX_CLUSTER_TIME]);
            csvData.push(['AVAILABLE_WORKERS', AVAILABLE_WORKERS]);
            csvData.push(['TIME_PER_AED', TIME_PER_AED]);
            csvData.push(['AED_LOCATION_BUFFER', AED_LOCATION_BUFFER]);
            csvData.push(['TIME_PER_50K_GSF', TIME_PER_50K_GSF]);
            csvData.push(['WALKING_SPEED_MPH', WALKING_SPEED_MPH]);
            csvData.push(['DRIVING_SPEED_MPH', DRIVING_SPEED_MPH]);
            csvData.push(['WALKING_THRESHOLD', WALKING_THRESHOLD]);
            csvData.push(['PARKING_TIME', PARKING_TIME]);
            csvData.push(['']);
            
            // Building data header
            csvData.push(['# BUILDING_DATA']);
            csvData.push(['code', 'name', 'gsf', 'aedCount', 'lat', 'lon', 'aedLocationBuffer', 'address']);
            
            // Building data rows
            buildingData.forEach(building => {
                csvData.push([
                    building.code || '',
                    building.name || '',
                    building.gsf || 0,
                    building.aedCount || 0,
                    building.lat || 0,
                    building.lon || 0,
                    building.aedLocationBuffer || '',
                    buildingAddresses[building.code] || ''
                ]);
            });
            
            csvData.push(['']);
            
            // Custom travel times
            csvData.push(['# CUSTOM_TRAVEL_TIMES']);
            csvData.push(['fromCode', 'toCode', 'time', 'method', 'useStraightLine']);
            
            if (window.customTravelTimes) {
                Object.keys(window.customTravelTimes).forEach(key => {
                    const [fromCode, toCode] = key.split('-');
                    const travel = window.customTravelTimes[key];
                    csvData.push([fromCode, toCode, travel.time, travel.method, travel.useStraightLine || false]);
                });
            }
            
            // Convert to CSV string
            const csvString = csvData.map(row => 
                row.map(cell => {
                    // Escape quotes and wrap in quotes if necessary
                    const cellStr = String(cell);
                    if (cellStr.includes(',') || cellStr.includes('"') || cellStr.includes('\n')) {
                        return '"' + cellStr.replace(/"/g, '""') + '"';
                    }
                    return cellStr;
                }).join(',')
            ).join('\n');
            
            // Create and download file
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'cu_boulder_aed_state.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            return true;
        } catch (error) {
            console.error('Error saving state:', error);
            alert('Error saving state to CSV: ' + error.message);
            return false;
        }
    }
    
    async function loadStateFromCSV(csvText) {
        try {
            const lines = csvText.split('\n').map(line => line.trim()).filter(line => line);
            let currentSection = null;
            let globalSettings = {};
            let buildingDataNew = [];
            let customTravelTimesNew = {};
            
            for (let line of lines) {
                // Skip comments and empty lines
                if (line.startsWith('#')) {
                    if (line.includes('GLOBAL_SETTINGS')) {
                        currentSection = 'GLOBAL_SETTINGS';
                    } else if (line.includes('BUILDING_DATA')) {
                        currentSection = 'BUILDING_DATA';
                    } else if (line.includes('CUSTOM_TRAVEL_TIMES')) {
                        currentSection = 'CUSTOM_TRAVEL_TIMES';
                    }
                    continue;
                }
                
                // Parse CSV line (simple parser)
                const values = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"' && (i === 0 || line[i-1] === ',')) {
                        inQuotes = true;
                    } else if (char === '"' && inQuotes && (i === line.length - 1 || line[i+1] === ',')) {
                        inQuotes = false;
                    } else if (char === ',' && !inQuotes) {
                        values.push(current.replace(/""/g, '"'));
                        current = '';
                    } else {
                        current += char;
                    }
                }
                values.push(current.replace(/""/g, '"'));
                
                if (currentSection === 'GLOBAL_SETTINGS' && values.length >= 2) {
                    globalSettings[values[0]] = parseFloat(values[1]) || values[1];
                } else if (currentSection === 'BUILDING_DATA' && values.length >= 6) {
                    // Skip header row
                    if (values[0] !== 'code') {
                        buildingDataNew.push({
                            code: values[0],
                            name: values[1],
                            gsf: parseInt(values[2]) || 0,
                            aedCount: parseInt(values[3]) || 0,
                            lat: parseFloat(values[4]) || 0,
                            lon: parseFloat(values[5]) || 0,
                            aedLocationBuffer: parseFloat(values[6]) || null,
                            address: values[7] || ''
                        });
                    }
                } else if (currentSection === 'CUSTOM_TRAVEL_TIMES' && values.length >= 4) {
                    // Skip header row
                    if (values[0] !== 'fromCode') {
                        const key = `${values[0]}-${values[1]}`;
                        customTravelTimesNew[key] = {
                            time: parseFloat(values[2]),
                            method: values[3],
                            useStraightLine: values[4] === 'true' || values[4] === true
                        };
                    }
                }
            }
            
            // Apply loaded data
            if (Object.keys(globalSettings).length > 0) {
                window.MAX_CLUSTER_TIME = globalSettings.MAX_CLUSTER_TIME || MAX_CLUSTER_TIME;
                window.AVAILABLE_WORKERS = globalSettings.AVAILABLE_WORKERS || AVAILABLE_WORKERS;
                window.TIME_PER_AED = globalSettings.TIME_PER_AED || TIME_PER_AED;
                window.AED_LOCATION_BUFFER = globalSettings.AED_LOCATION_BUFFER || AED_LOCATION_BUFFER;
                window.TIME_PER_50K_GSF = globalSettings.TIME_PER_50K_GSF || TIME_PER_50K_GSF;
                window.WALKING_SPEED_MPH = globalSettings.WALKING_SPEED_MPH || WALKING_SPEED_MPH;
                window.DRIVING_SPEED_MPH = globalSettings.DRIVING_SPEED_MPH || DRIVING_SPEED_MPH;
                window.WALKING_THRESHOLD = globalSettings.WALKING_THRESHOLD || WALKING_THRESHOLD;
                window.PARKING_TIME = globalSettings.PARKING_TIME || PARKING_TIME;
                
                // Update global constants
                MAX_CLUSTER_TIME = window.MAX_CLUSTER_TIME;
                AVAILABLE_WORKERS = window.AVAILABLE_WORKERS;
                TIME_PER_AED = window.TIME_PER_AED;
                AED_LOCATION_BUFFER = window.AED_LOCATION_BUFFER;
                TIME_PER_50K_GSF = window.TIME_PER_50K_GSF;
                WALKING_SPEED_MPH = window.WALKING_SPEED_MPH;
                DRIVING_SPEED_MPH = window.DRIVING_SPEED_MPH;
                WALKING_THRESHOLD = window.WALKING_THRESHOLD;
                PARKING_TIME = window.PARKING_TIME;
                METERS_PER_MINUTE_WALKING = (WALKING_SPEED_MPH * 1609.34) / 60;
                METERS_PER_MINUTE_DRIVING = (DRIVING_SPEED_MPH * 1609.34) / 60;
            }
            
            if (buildingDataNew.length > 0) {
                // Update building data
                buildingDataNew.forEach(newBuilding => {
                    const existingBuilding = buildingData.find(b => b.code === newBuilding.code);
                    if (existingBuilding) {
                        // Update existing building
                        Object.assign(existingBuilding, newBuilding);
                    } else {
                        // Add new building
                        buildingData.push(newBuilding);
                    }
                    
                    // Update address mapping
                    if (newBuilding.address) {
                        buildingAddresses[newBuilding.code] = newBuilding.address;
                    }
                });
            }
            
            if (Object.keys(customTravelTimesNew).length > 0) {
                window.customTravelTimes = customTravelTimesNew;
            }
            
            return true;
        } catch (error) {
            console.error('Error loading state:', error);
            alert('Error loading state from CSV: ' + error.message);
            return false;
        }
    }
    
    function addSaveButton() {
        const saveBtn = document.createElement('button');
        saveBtn.textContent = 'Save State to CSV';
        saveBtn.style.cssText = `
            display: block; width: 100%; padding: 8px; font-size: 0.9em; font-weight: bold;
            background-color: #17a2b8; color: white; border: none; border-radius: 5px;
            cursor: pointer; margin-bottom: 10px; transition: background-color 0.2s;
        `;
        saveBtn.addEventListener('mouseover', () => saveBtn.style.backgroundColor = '#138496');
        saveBtn.addEventListener('mouseout', () => saveBtn.style.backgroundColor = '#17a2b8');
        
        saveBtn.addEventListener('click', async () => {
            saveBtn.textContent = 'Saving...';
            saveBtn.disabled = true;
            
            const success = await saveStateToCSV();
            
            if (success) {
                saveBtn.textContent = 'Saved!';
                saveBtn.style.backgroundColor = '#28a745';
                setTimeout(() => {
                    saveBtn.textContent = 'Save State to CSV';
                    saveBtn.style.backgroundColor = '#17a2b8';
                    saveBtn.disabled = false;
                }, 2000);
            } else {
                saveBtn.textContent = 'Error - Try Again';
                saveBtn.style.backgroundColor = '#dc3545';
                setTimeout(() => {
                    saveBtn.textContent = 'Save State to CSV';
                    saveBtn.style.backgroundColor = '#17a2b8';
                    saveBtn.disabled = false;
                }, 2000);
            }
        });
        
        document.querySelector('.button-controls').appendChild(saveBtn);
    }
    
    function addLoadButton() {
        const loadContainer = document.createElement('div');
        loadContainer.style.cssText = 'margin-bottom: 10px;';
        
        const loadBtn = document.createElement('button');
        loadBtn.textContent = 'Load State from CSV';
        loadBtn.style.cssText = `
            display: block; width: 100%; padding: 8px; font-size: 0.9em; font-weight: bold;
            background-color: #20c997; color: white; border: none; border-radius: 5px;
            cursor: pointer; margin-bottom: 5px; transition: background-color 0.2s;
        `;
        loadBtn.addEventListener('mouseover', () => loadBtn.style.backgroundColor = '#1ba97e');
        loadBtn.addEventListener('mouseout', () => loadBtn.style.backgroundColor = '#20c997');
        
        // Hidden file input
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.csv';
        fileInput.style.display = 'none';
        
        loadBtn.addEventListener('click', () => {
            fileInput.click();
        });
        
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            loadBtn.textContent = 'Loading...';
            loadBtn.disabled = true;
            
            try {
                const text = await file.text();
                const success = await loadStateFromCSV(text);
                
                if (success) {
                    loadBtn.textContent = 'Loaded Successfully!';
                    loadBtn.style.backgroundColor = '#28a745';
                    
                    // Regenerate clusters with loaded data
                    processAndDisplayData();
                    
                    setTimeout(() => {
                        loadBtn.textContent = 'Load State from CSV';
                        loadBtn.style.backgroundColor = '#20c997';
                        loadBtn.disabled = false;
                    }, 2000);
                } else {
                    loadBtn.textContent = 'Error - Try Again';
                    loadBtn.style.backgroundColor = '#dc3545';
                    setTimeout(() => {
                        loadBtn.textContent = 'Load State from CSV';
                        loadBtn.style.backgroundColor = '#20c997';
                        loadBtn.disabled = false;
                    }, 2000);
                }
            } catch (error) {
                console.error('File read error:', error);
                loadBtn.textContent = 'Error - Try Again';
                loadBtn.style.backgroundColor = '#dc3545';
                setTimeout(() => {
                    loadBtn.textContent = 'Load State from CSV';
                    loadBtn.style.backgroundColor = '#20c997';
                    loadBtn.disabled = false;
                }, 2000);
            }
            
            // Reset file input
            fileInput.value = '';
        });
        
        loadContainer.appendChild(loadBtn);
        loadContainer.appendChild(fileInput);
        document.querySelector('.button-controls').appendChild(loadContainer);
    }

    // --- INITIAL LOAD & EVENT LISTENERS ---
    addGeocodeButton();
    addZoomButton();
    addGlobalVarsButton();
    addSaveButton();
    addLoadButton();
    addPDFButton();
    processAndDisplayData();
    recalcButton.addEventListener('click', processAndDisplayData);
    
    // Add event listener for "Recalculate Times Only" button
    document.getElementById('recalculate-times-btn').addEventListener('click', () => {
        if (currentClusters && currentClusters.length > 0) {
            recalculateTimesOnly();
        } else {
            alert('Please generate clusters first by clicking "Recalculate Clusters"');
        }
    });
    
    // Add hover effect for the new button
    const recalcTimesBtn = document.getElementById('recalculate-times-btn');
    recalcTimesBtn.addEventListener('mouseover', () => recalcTimesBtn.style.backgroundColor = '#e67e22');
    recalcTimesBtn.addEventListener('mouseout', () => recalcTimesBtn.style.backgroundColor = '#f39c12');
    
    // Add hover effect for add building button
    const addBuildingBtn = document.getElementById('add-building-btn');
    addBuildingBtn.addEventListener('mouseover', () => addBuildingBtn.style.backgroundColor = '#218838');
    addBuildingBtn.addEventListener('mouseout', () => addBuildingBtn.style.backgroundColor = '#28a745');
    
    // Add building functionality
    let isSelectingLocation = false;
    addBuildingBtn.addEventListener('click', () => {
        document.getElementById('add-building-modal').style.display = 'block';
        // Reset form
        document.getElementById('add-building-form').reset();
        document.getElementById('building-aed-count').value = '1';
    });
    
    // Building spreadsheet functionality
    const buildingListBtn = document.getElementById('building-list-btn');
    buildingListBtn.addEventListener('mouseover', () => buildingListBtn.style.backgroundColor = '#138496');
    buildingListBtn.addEventListener('mouseout', () => buildingListBtn.style.backgroundColor = '#17a2b8');
    buildingListBtn.addEventListener('click', () => {
        const modal = document.getElementById('building-list-modal');
        if (modal) {
            modal.style.display = 'block';
            // Add small delay to ensure modal is fully rendered
            setTimeout(() => {
                populateBuildingSpreadsheet();
            }, 50);
        }
    });
    
    // Time-based cluster functionality
    const timeClusterBtn = document.getElementById('time-cluster-btn');
    timeClusterBtn.addEventListener('mouseover', () => timeClusterBtn.style.backgroundColor = '#e55a00');
    timeClusterBtn.addEventListener('mouseout', () => timeClusterBtn.style.backgroundColor = '#fd7e14');
    timeClusterBtn.addEventListener('click', () => {
        console.log('Time cluster button clicked');
        const modal = document.getElementById('time-cluster-modal');
        if (modal) {
            modal.style.display = 'block';
            console.log('Modal opened');
            
            // Reset the form
            const minutesInput = document.getElementById('available-minutes');
            const hoursInput = document.getElementById('available-hours');
            const preview = document.getElementById('cluster-preview');
            
            if (minutesInput) minutesInput.value = '';
            if (hoursInput) hoursInput.value = '';
            if (preview) preview.style.display = 'none';
            
            console.log('Form reset completed');
        } else {
            console.error('Could not find time-cluster-modal element');
        }
    });
    
    // Campus mode toggle handler
    document.getElementById('campus-mode').addEventListener('change', function() {
        const campusMode = this.checked;
        console.log('Campus mode toggled:', campusMode ? 'ON' : 'OFF');
        
        if (campusMode) {
            // Clear any existing actual route times when switching to campus mode
            actualRouteTimes = {};
            console.log('Cleared actual route times for campus mode');
        }
        
        // Refresh the display
        displayClusters();
        
        // Update routes based on mode
        setTimeout(() => {
            if (!campusMode) {
                // Only fetch actual routes if not in campus mode
                enhanceRoutesWithActualPaths();
            }
            updateTotalTimeSummary();
        }, 100);
    });
    
    new ResizeObserver(() => map.invalidateSize()).observe(mapElement);
    
    // --- RESIZABLE PANES & FOCUS MODE FUNCTIONALITY ---
    function initializeResizablePanes() {
        const resizeHandle = document.querySelector('.resize-handle');
        const summaryPanel = document.getElementById('summary');
        const mapElement = document.getElementById('map');
        let isResizing = false;
        let startX = 0;
        let startWidth = 0;
        
        resizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            startX = e.clientX;
            startWidth = summaryPanel.offsetWidth;
            resizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ew-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            
            const deltaX = e.clientX - startX;
            const newWidth = startWidth + deltaX;
            const minWidth = 250;
            const maxWidth = window.innerWidth * 0.6;
            
            if (newWidth >= minWidth && newWidth <= maxWidth) {
                summaryPanel.style.width = newWidth + 'px';
                map.invalidateSize(); // Refresh map when panel resizes
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                resizeHandle.classList.remove('dragging');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                
                // Save the current width to localStorage
                localStorage.setItem('summaryPanelWidth', summaryPanel.offsetWidth);
            }
        });
        
        // Restore saved width on load
        const savedWidth = localStorage.getItem('summaryPanelWidth');
        if (savedWidth) {
            const width = parseInt(savedWidth);
            const maxWidth = window.innerWidth * 0.6;
            if (width >= 250 && width <= maxWidth) {
                summaryPanel.style.width = width + 'px';
            }
        }
    }
    
    function initializeFocusMode() {
        const focusToggle = document.getElementById('focus-toggle');
        const summaryPanel = document.getElementById('summary');
        let focusMode = false;
        
        // Restore focus mode state
        const savedFocusMode = localStorage.getItem('blockFocusMode') === 'true';
        if (savedFocusMode) {
            toggleFocusMode(true);
        }
        
        focusToggle.addEventListener('click', () => {
            toggleFocusMode();
        });
        
        function toggleFocusMode(force = null) {
            focusMode = force !== null ? force : !focusMode;
            
            if (focusMode) {
                summaryPanel.classList.add('focus-mode');
                focusToggle.classList.add('active');
                focusToggle.textContent = 'üìã Exit Focus';
                focusToggle.title = 'Exit Block Focus Mode';
            } else {
                summaryPanel.classList.remove('focus-mode');
                focusToggle.classList.remove('active');
                focusToggle.textContent = 'üìã Focus';
                focusToggle.title = 'Enter Block Focus Mode - Hide buttons for better work block view';
            }
            
            // Save focus mode state
            localStorage.setItem('blockFocusMode', focusMode);
            
            // Trigger map resize after a brief delay to account for layout changes
            setTimeout(() => {
                map.invalidateSize();
            }, 100);
        }
        
        // Add keyboard shortcut for focus mode (F key)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'f' || e.key === 'F') {
                // Only trigger if not typing in an input field
                if (!e.target.matches('input, textarea, select')) {
                    e.preventDefault();
                    toggleFocusMode();
                }
            }
        });
    }
    
    // Initialize the new functionality
    initializeResizablePanes();
    initializeFocusMode();
    initializeBuildingSpreadsheet();
    initializeTimeClusterModal();
    initializeBuildingStatus();
});

// --- BUILDING STATUS MANAGEMENT ---
function initializeBuildingStatus() {
    // Initialize checked status for all buildings if not already set
    buildingData.forEach(building => {
        if (building.checked === undefined) {
            building.checked = false;
        }
    });
    
    // Load saved status from localStorage
    const savedStatus = localStorage.getItem('buildingCheckedStatus');
    if (savedStatus) {
        try {
            const statusMap = JSON.parse(savedStatus);
            buildingData.forEach(building => {
                if (statusMap[building.code] !== undefined) {
                    building.checked = statusMap[building.code];
                }
            });
        } catch (error) {
            console.error('Error loading building status:', error);
        }
    }
}

function saveBuildingStatus() {
    const statusMap = {};
    buildingData.forEach(building => {
        statusMap[building.code] = building.checked || false;
    });
    localStorage.setItem('buildingCheckedStatus', JSON.stringify(statusMap));
}

function toggleBuildingStatus(buildingCode, updateClusters = true) {
    const building = buildingData.find(b => b.code === buildingCode);
    if (building) {
        building.checked = !building.checked;
        
        // Update building in current clusters
        currentClusters.forEach(cluster => {
            cluster.path.forEach(b => {
                if (b.code === buildingCode) {
                    b.checked = building.checked;
                }
            });
        });
        
        saveBuildingStatus();
        
        if (updateClusters) {
            // Update display to show checked status
            displayClusters();
        }
        
        console.log(`Building ${buildingCode} marked as ${building.checked ? 'checked' : 'unchecked'}`);
        return building.checked;
    }
    return false;
}

// Make toggleBuildingStatus globally accessible
window.toggleBuildingStatus = toggleBuildingStatus;

// Special version for spreadsheet that updates visual state immediately
function toggleBuildingStatusInSpreadsheet(buildingCode) {
    // Toggle the building status
    const wasChecked = toggleBuildingStatus(buildingCode, false);
    
    // Find the checkbox that was clicked and update row styling
    const checkboxes = document.querySelectorAll('.status-checkbox');
    checkboxes.forEach(checkbox => {
        const onchange = checkbox.getAttribute('onchange');
        if (onchange && onchange.includes(`'${buildingCode}'`)) {
            const row = checkbox.closest('tr');
            if (row) {
                if (wasChecked) {
                    row.classList.add('checked');
                } else {
                    row.classList.remove('checked');
                }
                
                // Update the text styling too
                const cells = row.querySelectorAll('td');
                cells.forEach(cell => {
                    if (wasChecked) {
                        cell.style.textDecoration = 'line-through';
                        cell.style.color = '#666';
                    } else {
                        cell.style.textDecoration = 'none';
                        cell.style.color = '';
                    }
                });
            }
        }
    });
    
    // Update the statistics display
    const buildingStats = document.getElementById('building-stats');
    if (buildingStats) {
        const totalBuildings = buildingData.length;
        const checkedBuildings = buildingData.filter(b => b.checked).length;
        const uncheckedBuildings = totalBuildings - checkedBuildings;
        const filteredBuildings = getFilteredBuildings();
        
        const statsText = filteredBuildings.length === totalBuildings 
            ? `${totalBuildings} buildings ‚Ä¢ ${checkedBuildings} checked ‚Ä¢ ${uncheckedBuildings} remaining`
            : `${filteredBuildings.length} of ${totalBuildings} buildings shown ‚Ä¢ ${checkedBuildings} checked ‚Ä¢ ${uncheckedBuildings} remaining`;
        
        buildingStats.textContent = statsText;
    }
    
    // Update cluster display too
    displayClusters();
}

// Make it globally accessible
window.toggleBuildingStatusInSpreadsheet = toggleBuildingStatusInSpreadsheet;

// Make function globally accessible
window.markClusterAsChecked = function(clusterIndex) {
    console.log(`markClusterAsChecked called with index: ${clusterIndex}`);
    
    if (!currentClusters || !currentClusters[clusterIndex]) {
        console.error(`Invalid cluster index: ${clusterIndex}. Available clusters:`, currentClusters);
        alert('‚ùå Error: Invalid work block selected');
        return;
    }
    
    const cluster = currentClusters[clusterIndex];
    let changedCount = 0;
    
    console.log(`Processing Work Block ${clusterIndex + 1} with ${cluster.path.length} buildings`);
    
    cluster.path.forEach(building => {
        if (!building.checked) {
            building.checked = true;
            changedCount++;
            
            // Update in main building data too
            const mainBuilding = buildingData.find(b => b.code === building.code);
            if (mainBuilding) {
                mainBuilding.checked = true;
            }
        }
    });
    
    saveBuildingStatus();
    displayClusters();
    
    // Also refresh spreadsheet if it's open - add small delay to ensure updates are processed
    setTimeout(() => {
        refreshSpreadsheet();
    }, 100);
    
    console.log(`Marked ${changedCount} buildings as checked in Work Block ${clusterIndex + 1}`);
    alert(`‚úÖ Marked ${changedCount} buildings in Work Block ${clusterIndex + 1} as checked!`);
};

// --- BUILDING SPREADSHEET FUNCTIONALITY ---
let buildingFilters = {
    status: '',
    code: '',
    name: '',
    gsf: '',
    aeds: '',
    cluster: '',
    lat: '',
    lon: ''
};

function initializeBuildingSpreadsheet() {
    // Wait for DOM to be ready
    setTimeout(() => {
        try {
            // Close modal when clicking outside
            const modal = document.getElementById('building-list-modal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target.id === 'building-list-modal') {
                        closeBuildingSpreadsheet();
                    }
                });
            }
            
            // Setup filter event listeners
            setupFilterListeners();
            
        } catch (error) {
            console.error('Error initializing building spreadsheet:', error);
        }
    }, 100);
}

function closeBuildingSpreadsheet() {
    try {
        const modal = document.getElementById('building-list-modal');
        if (modal) {
            modal.style.display = 'none';
        }
    } catch (error) {
        console.error('Error closing spreadsheet:', error);
    }
}

// Make functions globally accessible for button clicks
window.closeBuildingSpreadsheet = closeBuildingSpreadsheet;

function setupFilterListeners() {
    const filterIds = ['filter-status', 'filter-code', 'filter-name', 'filter-gsf', 'filter-aeds', 'filter-cluster', 'filter-lat', 'filter-lon'];
    
    filterIds.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.addEventListener('input', applyFilters);
            element.addEventListener('change', applyFilters);
        }
    });
}

function clearAllFilters() {
    // Reset all filter values
    Object.keys(buildingFilters).forEach(key => {
        buildingFilters[key] = '';
        const element = document.getElementById(`filter-${key}`);
        if (element) {
            element.value = '';
        }
    });
    
    // Re-populate without filters
    populateBuildingSpreadsheet();
}

// Make functions globally accessible for button clicks
window.clearAllFilters = clearAllFilters;

function populateBuildingSpreadsheet() {
    const tableBody = document.getElementById('building-table-body');
    const buildingStats = document.getElementById('building-stats');
    
    if (!tableBody || !buildingStats) {
        console.error('Required spreadsheet elements not found');
        return;
    }
    
    // Populate cluster filter options
    populateClusterFilter();
    
    // Filter buildings based on current filters
    const filteredBuildings = getFilteredBuildings();
    
    // Calculate stats
    const totalBuildings = buildingData.length;
    const filteredCount = filteredBuildings.length;
    const checkedBuildings = buildingData.filter(b => b.checked).length;
    const uncheckedBuildings = totalBuildings - checkedBuildings;
    
    const statsText = filteredCount === totalBuildings 
        ? `${totalBuildings} buildings ‚Ä¢ ${checkedBuildings} checked ‚Ä¢ ${uncheckedBuildings} remaining`
        : `${filteredCount} of ${totalBuildings} buildings shown ‚Ä¢ ${checkedBuildings} checked ‚Ä¢ ${uncheckedBuildings} remaining`;
    
    buildingStats.textContent = statsText;
    
    // Clear existing content
    tableBody.innerHTML = '';
    
    // Add rows for filtered buildings
    filteredBuildings.forEach(building => {
        const row = document.createElement('tr');
        
        // Add checked class for styling
        if (building.checked) {
            row.classList.add('checked');
        }
        
        // Find which cluster this building belongs to
        let clusterAssignment = 'Unassigned';
        if (currentClusters && Array.isArray(currentClusters)) {
            currentClusters.forEach((cluster, index) => {
                if (cluster.path.some(b => b.code === building.code)) {
                    clusterAssignment = `Work Block ${index + 1}`;
                }
            });
        }
        
        row.innerHTML = `
            <td>
                <input type="checkbox" class="status-checkbox" ${building.checked ? 'checked' : ''} 
                       onchange="toggleBuildingStatusInSpreadsheet('${building.code}');">
            </td>
            <td>${building.code}</td>
            <td>${building.name}</td>
            <td>${building.gsf || 0}</td>
            <td>${building.aedCount}</td>
            <td>
                <span class="cluster-badge" style="background-color: ${getClusterColor(clusterAssignment)};">
                    ${clusterAssignment}
                </span>
            </td>
            <td>${building.lat.toFixed(6)}</td>
            <td>${building.lon.toFixed(6)}</td>
            <td>
                <button onclick="window.editBuilding('${building.code}')" 
                        style="padding: 4px 8px; font-size: 0.8em; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px;">
                    Edit
                </button>
                <button onclick="map.setView([${building.lat}, ${building.lon}], 18); closeBuildingSpreadsheet();" 
                        style="padding: 4px 8px; font-size: 0.8em; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer;">
                    View
                </button>
            </td>
        `;
        
        tableBody.appendChild(row);
    });
    
    // Setup table sorting
    setupTableSorting();
}

function populateClusterFilter() {
    const clusterFilter = document.getElementById('filter-cluster');
    if (!clusterFilter) return;
    
    // Check if currentClusters exists (might not be defined yet on initial load)
    if (!currentClusters || !Array.isArray(currentClusters)) {
        return;
    }
    
    // Get existing options
    const existingOptions = Array.from(clusterFilter.options).map(opt => opt.value);
    
    // Add work block options that don't already exist
    currentClusters.forEach((cluster, index) => {
        const workBlockName = `Work Block ${index + 1}`;
        if (!existingOptions.includes(workBlockName)) {
            const option = document.createElement('option');
            option.value = workBlockName;
            option.textContent = workBlockName;
            clusterFilter.appendChild(option);
        }
    });
}

function getFilteredBuildings() {
    if (!buildingData || buildingData.length === 0) {
        return [];
    }
    
    return buildingData.filter(building => {
        // Find cluster assignment
        let clusterAssignment = 'Unassigned';
        if (currentClusters && Array.isArray(currentClusters)) {
            currentClusters.forEach((cluster, index) => {
                if (cluster.path.some(b => b.code === building.code)) {
                    clusterAssignment = `Work Block ${index + 1}`;
                }
            });
        }
        
        // Apply filters
        if (buildingFilters.status) {
            if (buildingFilters.status === 'checked' && !building.checked) return false;
            if (buildingFilters.status === 'unchecked' && building.checked) return false;
        }
        
        if (buildingFilters.code && !building.code.toLowerCase().includes(buildingFilters.code.toLowerCase())) {
            return false;
        }
        
        if (buildingFilters.name && !building.name.toLowerCase().includes(buildingFilters.name.toLowerCase())) {
            return false;
        }
        
        if (buildingFilters.gsf && (building.gsf || 0) < parseInt(buildingFilters.gsf)) {
            return false;
        }
        
        if (buildingFilters.aeds && building.aedCount < parseInt(buildingFilters.aeds)) {
            return false;
        }
        
        if (buildingFilters.cluster && clusterAssignment !== buildingFilters.cluster) {
            return false;
        }
        
        if (buildingFilters.lat && building.lat < parseFloat(buildingFilters.lat)) {
            return false;
        }
        
        if (buildingFilters.lon && building.lon < parseFloat(buildingFilters.lon)) {
            return false;
        }
        
        return true;
    });
}

function applyFilters() {
    // Update filter object from inputs
    buildingFilters.status = document.getElementById('filter-status')?.value || '';
    buildingFilters.code = document.getElementById('filter-code')?.value || '';
    buildingFilters.name = document.getElementById('filter-name')?.value || '';
    buildingFilters.gsf = document.getElementById('filter-gsf')?.value || '';
    buildingFilters.aeds = document.getElementById('filter-aeds')?.value || '';
    buildingFilters.cluster = document.getElementById('filter-cluster')?.value || '';
    buildingFilters.lat = document.getElementById('filter-lat')?.value || '';
    buildingFilters.lon = document.getElementById('filter-lon')?.value || '';
    
    // Re-populate table with filtered results
    populateBuildingSpreadsheet();
}

function refreshSpreadsheet() {
    // Update stats and re-render if spreadsheet is open
    const modal = document.getElementById('building-list-modal');
    if (modal && modal.style.display === 'block') {
        populateBuildingSpreadsheet();
    }
}

function getClusterColor(clusterAssignment) {
    const clusterIndex = parseInt(clusterAssignment.replace('Work Block ', '')) - 1;
    if (currentClusters && Array.isArray(currentClusters) && clusterIndex >= 0 && clusterIndex < currentClusters.length) {
        const colors = generateClusterColors(currentClusters.length);
        return colors[clusterIndex];
    }
    return '#6c757d'; // Gray for unassigned
}

function setupTableSorting() {
    const headers = document.querySelectorAll('.building-table th[data-sort]');
    headers.forEach(header => {
        header.addEventListener('click', () => {
            const sortKey = header.dataset.sort;
            sortBuildingTable(sortKey);
        });
    });
}

let currentSortKey = null;
let currentSortDirection = 'asc';

function sortBuildingTable(sortKey) {
    const tableBody = document.getElementById('building-table-body');
    const rows = Array.from(tableBody.querySelectorAll('tr'));
    
    if (rows.length === 0) return; // No data to sort
    
    // Toggle direction if same key
    if (currentSortKey === sortKey) {
        currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
    } else {
        currentSortDirection = 'asc';
    }
    currentSortKey = sortKey;
    
    // Sort rows
    rows.sort((a, b) => {
        let aValue, bValue;
        
        switch (sortKey) {
            case 'checked':
                aValue = a.classList.contains('checked') ? 1 : 0;
                bValue = b.classList.contains('checked') ? 1 : 0;
                break;
            case 'code':
                aValue = a.children[1].textContent;
                bValue = b.children[1].textContent;
                break;
            case 'name':
                aValue = a.children[2].textContent;
                bValue = b.children[2].textContent;
                break;
            case 'gsf':
                aValue = parseInt(a.children[3].textContent) || 0;
                bValue = parseInt(b.children[3].textContent) || 0;
                break;
            case 'aedCount':
                aValue = parseInt(a.children[4].textContent) || 0;
                bValue = parseInt(b.children[4].textContent) || 0;
                break;
            case 'cluster':
                aValue = a.children[5].textContent;
                bValue = b.children[5].textContent;
                break;
            case 'lat':
                aValue = parseFloat(a.children[6].textContent) || 0;
                bValue = parseFloat(b.children[6].textContent) || 0;
                break;
            case 'lon':
                aValue = parseFloat(a.children[7].textContent) || 0;
                bValue = parseFloat(b.children[7].textContent) || 0;
                break;
            default:
                return 0;
        }
        
        let comparison = 0;
        if (aValue < bValue) comparison = -1;
        if (aValue > bValue) comparison = 1;
        
        return currentSortDirection === 'asc' ? comparison : -comparison;
    });
    
    // Re-append sorted rows
    rows.forEach(row => tableBody.appendChild(row));
    
    // Update header indicators
    document.querySelectorAll('.building-table th .sort-indicator').forEach(indicator => {
        indicator.textContent = '‚Üï';
        indicator.style.opacity = '0.5';
    });
    
    const currentHeader = document.querySelector(`[data-sort="${sortKey}"] .sort-indicator`);
    if (currentHeader) {
        currentHeader.textContent = currentSortDirection === 'asc' ? '‚Üë' : '‚Üì';
        currentHeader.style.opacity = '1';
    }
}

function exportBuildingData() {
    const filteredBuildings = getFilteredBuildings();
    const allBuildings = buildingData;
    
    let buildingsToExport;
    let filename;
    
    // Ask user if they want filtered or all data
    if (filteredBuildings.length < allBuildings.length) {
        const choice = confirm(`Export Options:\n\nOK = Export ${filteredBuildings.length} filtered buildings\nCancel = Export all ${allBuildings.length} buildings`);
        buildingsToExport = choice ? filteredBuildings : allBuildings;
        filename = choice ? 'filtered_buildings' : 'all_buildings';
    } else {
        buildingsToExport = allBuildings;
        filename = 'all_buildings';
    }
    
    const headers = ['Status', 'Code', 'Name', 'GSF', 'AED_Count', 'Cluster', 'Latitude', 'Longitude', 'Checked'];
    
    const csvData = [headers];
    
    buildingsToExport.forEach(building => {
        // Find cluster assignment
        let clusterAssignment = 'Unassigned';
        currentClusters.forEach((cluster, index) => {
            if (cluster.path.some(b => b.code === building.code)) {
                clusterAssignment = `Work Block ${index + 1}`;
            }
        });
        
        csvData.push([
            building.checked ? 'Checked' : 'Unchecked',
            building.code,
            building.name,
            building.gsf || 0,
            building.aedCount,
            clusterAssignment,
            building.lat,
            building.lon,
            building.checked ? 'TRUE' : 'FALSE'
        ]);
    });
    
    const csvContent = csvData.map(row => 
        row.map(field => `"${field}"`).join(',')
    ).join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${filename}_${new Date().toISOString().split('T')[0]}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
    
    console.log(`Exported ${buildingsToExport.length} buildings to CSV`);
}

// Make functions globally accessible for button clicks
window.exportBuildingData = exportBuildingData;

// --- TIME-BASED CLUSTER FUNCTIONALITY ---
function initializeTimeClusterModal() {
    // Wait for DOM to be ready
    setTimeout(() => {
        try {
            // Cancel button
            const cancelBtn = document.getElementById('cancel-time-cluster-btn');
            if (cancelBtn) {
                cancelBtn.addEventListener('click', closeTimeClusterModal);
            }
            
            // Close modal when clicking outside
            const modal = document.getElementById('time-cluster-modal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target.id === 'time-cluster-modal') {
                        closeTimeClusterModal();
                    }
                });
            }
            
            // Sync time inputs
            const minutesInput = document.getElementById('available-minutes');
            if (minutesInput) {
                minutesInput.addEventListener('input', (e) => {
                    const minutes = parseFloat(e.target.value);
                    if (!isNaN(minutes) && minutes > 0) {
                        const hoursInput = document.getElementById('available-hours');
                        if (hoursInput) {
                            hoursInput.value = (minutes / 60).toFixed(1);
                        }
                    }
                });
            }
            
            const hoursInput = document.getElementById('available-hours');
            if (hoursInput) {
                hoursInput.addEventListener('input', (e) => {
                    const hours = parseFloat(e.target.value);
                    if (!isNaN(hours) && hours > 0) {
                        const minutesInput = document.getElementById('available-minutes');
                        if (minutesInput) {
                            minutesInput.value = Math.round(hours * 60);
                        }
                    }
                });
            }
            
            // Calculate cluster button
            const calculateBtn = document.getElementById('calculate-cluster-btn');
            if (calculateBtn) {
                calculateBtn.addEventListener('click', calculateTimeBasedCluster);
            }
            
            // Option buttons
            const pluckBtn = document.getElementById('pluck-buildings-btn');
            if (pluckBtn) {
                pluckBtn.addEventListener('click', () => {
                    executeTimeClusterOption('pluck');
                });
            }
            
            const recalcBtn = document.getElementById('full-recalc-btn');
            if (recalcBtn) {
                recalcBtn.addEventListener('click', () => {
                    executeTimeClusterOption('recalculate');
                });
            }
            
            console.log('Time cluster modal initialized successfully');
            
        } catch (error) {
            console.error('Error initializing time cluster modal:', error);
        }
    }, 100);
}

function closeTimeClusterModal() {
    try {
        const modal = document.getElementById('time-cluster-modal');
        if (modal) {
            modal.style.display = 'none';
            // Reset form
            const minutesInput = document.getElementById('available-minutes');
            const hoursInput = document.getElementById('available-hours');
            const preview = document.getElementById('cluster-preview');
            
            if (minutesInput) minutesInput.value = '';
            if (hoursInput) hoursInput.value = '';
            if (preview) preview.style.display = 'none';
        }
    } catch (error) {
        console.error('Error closing time cluster modal:', error);
    }
}

let currentTimeClusterData = null;

function calculateTimeBasedCluster() {
    console.log('calculateTimeBasedCluster function called');
    
    const minutesInput = document.getElementById('available-minutes')?.value;
    const hoursInput = document.getElementById('available-hours')?.value;
    
    console.log('Input values:', { minutesInput, hoursInput });
    
    // Get available time in minutes
    let availableMinutes;
    if (minutesInput) {
        availableMinutes = parseFloat(minutesInput);
    } else if (hoursInput) {
        availableMinutes = parseFloat(hoursInput) * 60;
    } else {
        alert('Please enter available time in minutes or hours.');
        return;
    }
    
    if (isNaN(availableMinutes) || availableMinutes <= 0) {
        alert('Please enter a valid positive time amount.');
        return;
    }
    
    // Get all unchecked buildings
    const uncheckedBuildings = buildingData.filter(b => !b.checked);
    
    if (uncheckedBuildings.length === 0) {
        alert('üéâ All buildings have been checked! No unchecked buildings available for clustering.');
        return;
    }
    
    console.log(`Finding optimal cluster for ${availableMinutes} minutes with ${uncheckedBuildings.length} unchecked buildings`);
    
    // Calculate times for all buildings
    const buildingsWithTimes = uncheckedBuildings.map(building => {
        const inventoryTime = building.aedCount * TIME_PER_AED;
        const gsf = typeof building.gsf === 'number' && !isNaN(building.gsf) ? building.gsf : 0;
        const inBuildingTravelTime = gsf > 0 ? (gsf / 50000) * TIME_PER_50K_GSF : 0;
        const aedLocationTime = building.aedLocationBuffer || AED_LOCATION_BUFFER;
        const totalTime = inventoryTime + inBuildingTravelTime + aedLocationTime;
        
        return {
            ...building,
            totalTime: totalTime
        };
    });
    
    // Find optimal cluster using greedy algorithm with time constraints
    const optimalCluster = findOptimalTimeCluster(buildingsWithTimes, availableMinutes);
    
    if (optimalCluster.path.length === 0) {
        alert('‚ö†Ô∏è No suitable buildings found for the given time limit. Try increasing the available time.');
        return;
    }
    
    // Store for later use
    currentTimeClusterData = optimalCluster;
    
    // Update preview
    updateTimeClusterPreview(optimalCluster, availableMinutes);
    
    // Show preview section
    document.getElementById('cluster-preview').style.display = 'block';
}

function findOptimalTimeCluster(buildings, maxTime) {
    // Start with building that has most AEDs per minute
    let availableBuildings = buildings.slice();
    const selectedBuildings = [];
    let totalTime = 0;
    
    // Calculate efficiency for each building (AEDs per minute of work)
    availableBuildings.forEach(building => {
        building.efficiency = building.aedCount / building.totalTime;
    });
    
    // Sort by efficiency (AEDs per minute) descending
    availableBuildings.sort((a, b) => b.efficiency - a.efficiency);
    
    // Greedily select buildings that fit within time constraint
    while (availableBuildings.length > 0 && totalTime < maxTime) {
        let bestBuilding = null;
        let bestAddedTime = Infinity;
        
        // Try to find the best building that still fits
        for (let i = 0; i < availableBuildings.length; i++) {
            const building = availableBuildings[i];
            let addedTime = building.totalTime;
            
            // Add travel time if not first building
            if (selectedBuildings.length > 0) {
                const lastBuilding = selectedBuildings[selectedBuildings.length - 1];
                const travelTime = calculateTravelTimeSync(lastBuilding.lat, lastBuilding.lon, building.lat, building.lon, lastBuilding.code, building.code).time;
                addedTime += travelTime;
            }
            
            // Check if this building fits within time limit
            if (totalTime + addedTime <= maxTime) {
                // Prefer buildings with higher efficiency if they fit
                if (bestBuilding === null || building.efficiency > bestBuilding.efficiency || 
                   (Math.abs(building.efficiency - bestBuilding.efficiency) < 0.1 && addedTime < bestAddedTime)) {
                    bestBuilding = building;
                    bestAddedTime = addedTime;
                }
            }
        }
        
        if (bestBuilding === null) {
            break; // No more buildings fit
        }
        
        selectedBuildings.push(bestBuilding);
        totalTime += bestAddedTime;
        
        // Remove selected building from available
        availableBuildings = availableBuildings.filter(b => b.code !== bestBuilding.code);
    }
    
    return {
        path: selectedBuildings,
        totalTime: totalTime
    };
}

function updateTimeClusterPreview(cluster, availableMinutes) {
    const totalAEDs = cluster.path.reduce((sum, b) => sum + b.aedCount, 0);
    const efficiency = ((cluster.totalTime / availableMinutes) * 100);
    
    document.getElementById('preview-buildings').textContent = cluster.path.length;
    document.getElementById('preview-aeds').textContent = totalAEDs;
    document.getElementById('preview-time').textContent = Math.round(cluster.totalTime);
    document.getElementById('preview-efficiency').textContent = efficiency.toFixed(0);
    
    // Update building list
    const buildingList = document.getElementById('preview-building-list');
    buildingList.innerHTML = cluster.path.map((building, index) => `
        <div style="padding: 4px 0; border-bottom: 1px solid #eee; display: flex; justify-content: space-between;">
            <span>${index + 1}. ${building.code} - ${building.name.substring(0, 30)}${building.name.length > 30 ? '...' : ''}</span>
            <span style="color: #666; font-size: 0.9em;">${building.aedCount} AEDs, ${Math.round(building.totalTime)} min</span>
        </div>
    `).join('');
}

function executeTimeClusterOption(option) {
    if (!currentTimeClusterData) {
        alert('Please calculate a cluster first.');
        return;
    }
    
    const cluster = currentTimeClusterData;
    const action = option === 'pluck' ? 'pluck buildings from existing clusters' : 'create cluster and fully recalculate remaining buildings';
    
    if (!confirm(`Are you sure you want to ${action}?\n\nThis will create a new Work Block with ${cluster.path.length} buildings.`)) {
        return;
    }
    
    if (option === 'pluck') {
        // Remove buildings from existing clusters but don't recalculate others
        cluster.path.forEach(building => {
            // Remove from existing clusters
            currentClusters.forEach(existingCluster => {
                existingCluster.path = existingCluster.path.filter(b => b.code !== building.code);
            });
        });
        
        // Remove empty clusters
        currentClusters = currentClusters.filter(c => c.path.length > 0);
        
        // Add new cluster
        currentClusters.push({
            path: cluster.path,
            totalTime: cluster.totalTime
        });
        
        alert(`‚úÖ Successfully plucked ${cluster.path.length} buildings into a new Work Block!\n\nExisting clusters remain unchanged.`);
        
    } else {
        // Full recalculation: remove buildings and recalculate everything
        const remainingBuildings = buildingData.filter(building => 
            !cluster.path.some(clusterBuilding => clusterBuilding.code === building.code)
        );
        
        // Generate new clusters with remaining buildings
        currentClusters = generateClusters(remainingBuildings);
        
        // Add the time-based cluster
        currentClusters.push({
            path: cluster.path,
            totalTime: cluster.totalTime
        });
        
        alert(`‚úÖ Successfully created new Work Block and recalculated all clusters!\n\nGenerated ${currentClusters.length - 1} work blocks for remaining buildings plus 1 time-based block.`);
    }
    
    // Update display
    displayClusters();
    updateTotalTimeSummary();
    
    // Close modal
    document.getElementById('time-cluster-modal').style.display = 'none';
    
    // Clear current data
    currentTimeClusterData = null;
    document.getElementById('cluster-preview').style.display = 'none';
}

// --- ADD BUILDING FUNCTIONALITY ---
function initializeAddBuildingModal() {
    const modal = document.getElementById('add-building-modal');
    const form = document.getElementById('add-building-form');
    const cancelBtn = document.getElementById('cancel-add-building');
    const geocodeBtn = document.getElementById('geocode-address-btn');
    
    // Close modal when clicking cancel
    cancelBtn.addEventListener('click', () => {
        modal.style.display = 'none';
        isSelectingLocation = false;
    });
    
    // Close modal when clicking outside
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.style.display = 'none';
            isSelectingLocation = false;
        }
    });
    
    // Handle address geocoding
    geocodeBtn.addEventListener('click', async () => {
        const address = document.getElementById('building-address').value.trim();
        if (!address) {
            alert('Please enter an address first.');
            return;
        }
        
        geocodeBtn.textContent = 'Geocoding...';
        geocodeBtn.disabled = true;
        
        try {
            const result = await geocodeAddress(address, true);
            if (result) {
                document.getElementById('building-lat').value = result.lat.toFixed(6);
                document.getElementById('building-lon').value = result.lon.toFixed(6);
                alert('‚úÖ Address geocoded successfully!');
            } else {
                alert('‚ùå Could not find coordinates for that address. Please try a different address or enter coordinates manually.');
            }
        } catch (error) {
            console.error('Geocoding error:', error);
            alert('‚ùå Error geocoding address. Please try again or enter coordinates manually.');
        } finally {
            geocodeBtn.textContent = 'üìç Geocode Address';
            geocodeBtn.disabled = false;
        }
    });
    
    // Handle form submission
    form.addEventListener('submit', (e) => {
        e.preventDefault();
        
        const formData = new FormData(form);
        const newBuilding = {
            code: formData.get('code').toUpperCase().trim(),
            name: formData.get('name').trim(),
            gsf: parseInt(formData.get('gsf')) || 0,
            aedCount: parseInt(formData.get('aedCount')) || 1,
            lat: parseFloat(formData.get('lat')),
            lon: parseFloat(formData.get('lon')),
            address: formData.get('address').trim()
        };
        
        // Validate required fields
        if (!newBuilding.code || !newBuilding.name || isNaN(newBuilding.lat) || isNaN(newBuilding.lon)) {
            alert('Please fill in all required fields (marked with *)');
            return;
        }
        
        // Check for duplicate building code
        if (buildingData.find(b => b.code === newBuilding.code)) {
            alert('A building with that code already exists. Please use a different code.');
            return;
        }
        
        // Validate coordinates (rough check for Boulder area)
        if (newBuilding.lat < 39.9 || newBuilding.lat > 40.1 || newBuilding.lon < -105.4 || newBuilding.lon > -105.1) {
            if (!confirm('The coordinates you entered seem to be outside the Boulder area. Are you sure you want to continue?')) {
                return;
            }
        }
        
        // Add to building data
        buildingData.push(newBuilding);
        
        // Close modal
        modal.style.display = 'none';
        isSelectingLocation = false;
        
        // Show success message
        alert(`‚úÖ Building "${newBuilding.name}" added successfully!`);
        
        // Regenerate clusters to include the new building
        processAndDisplayData();
        
        console.log('New building added:', newBuilding);
    });
    
    // Enable map clicking for coordinate selection (only if map is initialized)
    if (map && typeof map.on === 'function') {
        map.on('click', (e) => {
        if (modal.style.display === 'block') {
            const lat = e.latlng.lat.toFixed(6);
            const lon = e.latlng.lng.toFixed(6);
            document.getElementById('building-lat').value = lat;
            document.getElementById('building-lon').value = lon;
            
            // Optional: Add a temporary marker to show selected location
            if (window.tempLocationMarker) {
                map.removeLayer(window.tempLocationMarker);
            }
            window.tempLocationMarker = L.marker([lat, lon], {
                icon: L.divIcon({
                    html: '<div style="background: #ff6b35; border: 2px solid white; border-radius: 50%; width: 12px; height: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                    className: 'temp-location-marker',
                    iconSize: [12, 12],
                    iconAnchor: [6, 6]
                })
            }).addTo(map);
            
            // Remove temp marker when modal is closed
            const originalClose = () => {
                if (window.tempLocationMarker) {
                    map.removeLayer(window.tempLocationMarker);
                    window.tempLocationMarker = null;
                }
            };
            
            // Add to existing close handlers
            cancelBtn.addEventListener('click', originalClose, { once: true });
        }
    });
    }
}

</script>
</body>
</html>